<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phoebe&#39;s Blog</title>
  
  <subtitle>求知若饥，虚心若愚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-16T12:09:36.774Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Phoebe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>十道题</title>
    <link href="http://yoursite.com/2018/01/16/%E5%8D%81%E9%81%93%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/16/十道题/</id>
    <published>2018-01-16T11:54:42.000Z</published>
    <updated>2018-01-16T12:09:36.774Z</updated>
    
    <content type="html"><![CDATA[<h5 id="请写出一个符合-W3C-规范的-HTML-文件，要求："><a href="#请写出一个符合-W3C-规范的-HTML-文件，要求：" class="headerlink" title="请写出一个符合 W3C 规范的 HTML 文件，要求："></a>请写出一个符合 W3C 规范的 HTML 文件，要求：</h5><ul><li>页面标题为「我的页面」</li><li>页面中引入了一个外部 CSS 文件，文件路径为 /style.css</li><li>页面中引入了另一个外部 CSS 文件，路径为 /print.css，该文件仅在打印时生效</li><li>页面中引入了另一个外部 CSS 文件，路径为 /mobile.css，该文件仅在设备宽度小于 500 像素时生效</li><li>页面中引入了一个外部 JS 文件，路径为 /main.js</li><li>页面中引入了一个外部 JS 文件，路径为 /gbk.js，文件编码为 GBK</li><li>页面中有一个 SVG 标签，SVG 里面有一个直径为 100 像素的圆圈，颜色随意<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-Hans&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;我的页面&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;/print.css&quot; media=&quot;print&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;/mobile.css&quot; media=&quot;max-width:500px&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;svg width=&quot;100%&quot; height=&quot;200&quot;&gt;</span><br><span class="line">    &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;50&quot; fill=&quot;green&quot;/&gt;</span><br><span class="line">    &lt;/svg&gt; </span><br><span class="line">    &lt;script src=&quot;/main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;/gbk.js&quot; charset=&quot;GBK&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="移动端是怎么做适配的？"><a href="#移动端是怎么做适配的？" class="headerlink" title="移动端是怎么做适配的？"></a>移动端是怎么做适配的？</h5><p><a href="https://github.com/Bless-L/MyBlog/blob/master/post/2016%E8%85%BE%E8%AE%AF%E5%AE%9E%E4%B9%A0%E7%94%9F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%E5%8F%8A%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89.md" title="null" target="_blank" rel="external">2016年腾讯前端面试题</a></p><p>回答要点：</p><ul><li>meta viewport</li><li>媒体查询（<a href="https://xiedaimala.com/courses/003b1951-22af-4821-ad80-d2880c0074eb/tasks/f61cdba2-cea3-4da1-90b6-3f37bd8d6d5b" title="null" target="_blank" rel="external">教程</a>）</li><li>动态 rem 方案（<a href="https://xiedaimala.com/courses/003b1951-22af-4821-ad80-d2880c0074eb/tasks/37a886be-169c-4a99-8bfb-1a993be8119d" title="null" target="_blank" rel="external">教程</a>）</li></ul><h6 id="meta-viewport"><a href="#meta-viewport" class="headerlink" title="meta viewport"></a>meta viewport</h6><p>在HTML的<head>标签加meta进行移动端的适配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure></head></p><h6 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h6><p>使用 @media 查询，可以针对不同的媒体类型定义不同的样式。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media mediatype and|not|only (media feature) &#123;</span><br><span class="line">    CSS-Code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以针对不同的媒体使用不同 stylesheets (媒体类型是可选的，默认值是all):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;mystylesheet.css&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>实例：实现浏览器窗口小于 500px并将背景将变为绿色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media only screen and (max-width: 500px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h6><p>rem（font size of the root element）是指相对于根元素（即html元素）的字体大小的单位，即根据网页的根元素（html）来设置字体的大小。</p><ul><li>手机端方案的特点<br>a. 所有手机显示的界面都是一样的，只是大小不同<br>b. 1 rem == html font-size == viewport width</li><li><p>使用 JS 动态调整 REM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">     var pageWidth = window.innerWidth</span><br><span class="line">     document.write(&apos;&lt;style&gt;html&#123;font-size:&apos;+pageWidth+&apos;px;&#125;&lt;/style&gt;&apos;)</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>REM 可以与其他单位同时存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">font-size: 16px;</span><br><span class="line"> border: 1px solid red;</span><br><span class="line"> width: 0.5rem;</span><br></pre></td></tr></table></figure></li><li><p>在 SCSS 里使用 PX2REM，实现 px 自动转换 rem</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@function px( $px )&#123;</span><br><span class="line">  @return $px/$designWidth*10 + rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$designWidth : 750;  //750为设计稿的宽度</span><br><span class="line"></span><br><span class="line">.child&#123;</span><br><span class="line">  width: px(375);</span><br><span class="line">  height: px(160);</span><br><span class="line">  margin: px(40) px(40);</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  float: left;</span><br><span class="line">  font-size: 1.2em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="用过CSS3吗-实现圆角矩形和阴影怎么做"><a href="#用过CSS3吗-实现圆角矩形和阴影怎么做" class="headerlink" title="用过CSS3吗? 实现圆角矩形和阴影怎么做?"></a><a href="http://js.jirengu.com/koqix/2/edit?html,css,output" target="_blank" rel="external">用过CSS3吗? 实现圆角矩形和阴影怎么做?</a></h5><h5 id="请说出至少-8-个-HTTP-状态码，并描述各状态码的意义。"><a href="#请说出至少-8-个-HTTP-状态码，并描述各状态码的意义。" class="headerlink" title="请说出至少 8 个 HTTP 状态码，并描述各状态码的意义。"></a>请说出至少 8 个 HTTP 状态码，并描述各状态码的意义。</h5><ul><li><p>HTTP五种类型状态码<br>1XX：信息，服务器收到请求，需要请求者继续执行操作<br>2XX：成功，操作被成功接收并处理<br>3XX：重定向，需要进一步的操作以完成请求<br>4XX：客户端错误，请求包含语法错误或无法完成请求<br>5XX：服务器错误，服务器在处理请求的过程中发生了错误</p></li><li><p>205 //重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域。</p></li><li>302 //临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。</li><li>303 //查看其它地址。与301类似。使用GET和POST请求查看。</li><li>403 //服务器理解请求客户端的请求，但是拒绝执行此请求。</li><li>404 //服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>406 //服务器无法根据客户端请求的内容特性完成请求。</li><li>501 Not Implemented: 服务器不支持当前请求所需要的某个功能。</li><li>502 //服务器不支持请求的HTTP协议的版本，无法完成处理。</li></ul><h5 id="请说出至少三种排序的思路，这三种排序的时间复杂度分别为"><a href="#请说出至少三种排序的思路，这三种排序的时间复杂度分别为" class="headerlink" title="请说出至少三种排序的思路，这三种排序的时间复杂度分别为"></a>请说出至少三种排序的思路，这三种排序的时间复杂度分别为</h5><ul><li>O(n*n) </li><li>O(n log2 n)</li><li>O(n + max) </li></ul><p>O(n*n) 冒泡排序：冒泡排序：比较相邻的两个数，如果前面的数比后面的数大，就交换它们的位置。第一次比较，最大的数就排在了队尾。如此重复上面的操作，直到所有数据都排好序</p><p>O(n log2 n)堆排序<br>堆分为最大堆和最小堆，可以视为一棵完全的二叉树。以最大堆为例。最大堆要求父节点的元素都大于其孩子(子节点)。如果这个父节点的值要小于其左右子节点的值，那就要从其左右子节点中找出一个最大的值让它上浮顶替当前的父节点。而当前的父节点就下沉到之前子节点的位置。每一次排序都从最底层开始，自下而上的把每一个找到的最大堆值层层上浮，直到堆顶，然后取堆顶的值放到序列最后。依次类推，最终得到排序的序列。</p><p>O(n + max)基数排序<br>把一串数据从低位到高位依次比较各个位。先从个位开始，根据位值(0-9)分别放到0-9号桶中，再将放置在0~9号桶中的数据按顺序放到数组中。重复前面操作，直到数据从个位到最高位排好序。</p><h5 id="请写出一个-HTTP-post-请求的内容，包括四部分。"><a href="#请写出一个-HTTP-post-请求的内容，包括四部分。" class="headerlink" title="请写出一个 HTTP post 请求的内容，包括四部分。"></a>请写出一个 HTTP post 请求的内容，包括四部分。</h5><p>其中<br>第四部分的内容是 username=ff&amp;password=123<br>第二部分必须含有 Content-Type 字段<br>请求的路径为 /path<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Length: 10</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">user=ff&amp;password=123</span><br></pre></td></tr></table></figure></p><h5 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h5><p>分为以下几个过程：</p><ol><li>当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。</li><li>浏览器与远程Web服务器通过TCP三次握手来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</li><li>一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。</li><li>此时，Web服务器提供资源服务，客户端开始下载资源。包括如下过程：</li></ol><ul><li>浏览器开始下载html文档(响应报头，状态码200)，同时设置缓存。 </li><li>之后浏览器对整个 HTML 结构进行解析，形成 DOM 树；与此同时，它还需要对相应的 CSS 文件进行解析，形成 CSS 树（CSSOM）</li><li>接下来，需要结合 DOM + CSSOM，形成一个绘制树（Render Tree）</li><li>得到绘制树之后，浏览器开始布局渲染树并将其绘制到屏幕上，最后组合成一个页面。</li></ul><h5 id="如何实现数组去重？"><a href="#如何实现数组去重？" class="headerlink" title="如何实现数组去重？"></a>如何实现数组去重？</h5><p>假设有数组 array = [1,5,2,3,4,2,3,1,3,4]<br>你要写一个函数 unique，使得<br>unique(array) 的值为 [1,5,2,3,4]<br>也就是把重复的值都去掉，只保留不重复的值。<br>要求：<br>不要做多重循环，只能遍历一次<br>请给出两种方案，一种能在 ES 5 环境中运行，一种能在 ES 6 环境中运行（提示 ES 6 环境多了一个 Set 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ES 5:</span><br><span class="line">var array = [1,5,2,3,4,2,3,1,3,4]</span><br><span class="line">function unique(arr) &#123; </span><br><span class="line">   var newArr = []; </span><br><span class="line">   var object = &#123;&#125;;</span><br><span class="line">   for(var i=0,l=arr.length;i&lt;l;i++) &#123;</span><br><span class="line">     if(!object[arr[i]]) &#123;</span><br><span class="line">       object[arr[i]] = true;</span><br><span class="line">       newArr.push(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return newArr;</span><br><span class="line"> &#125;</span><br><span class="line">console.log(unique(array)); //[1, 5, 2, 3, 4]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ES 6:</span><br><span class="line">var array = [1,5,2,3,4,2,3,1,3,4]</span><br><span class="line">function unique (array) &#123;</span><br><span class="line">  return Array.from(new Set(array))</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique(array));  // [1, 5, 2, 3, 4]</span><br></pre></td></tr></table></figure><h5 id="call、apply、bind-的用法分别是什么？"><a href="#call、apply、bind-的用法分别是什么？" class="headerlink" title="call、apply、bind 的用法分别是什么？"></a>call、apply、bind 的用法分别是什么？</h5><ul><li>call()和apply()<br>call()接收一串单独的参数，apply()接收一个参数数组<br>apply()和call() 的作用基本上都差不多，只是接受参数的方式不太一样。它们都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。<ul><li>bind<br>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</li></ul></li></ul><ul><li>三者的比较<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;  </span><br><span class="line">    x: 81,  </span><br><span class="line">&#125;;  </span><br><span class="line">var foo = &#123;  </span><br><span class="line">    getX: function() &#123;  </span><br><span class="line">        return this.x;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line">console.log(foo.getX.bind(obj)());  //81  </span><br><span class="line">console.log(foo.getX.call(obj));    //81  </span><br><span class="line">console.log(foo.getX.apply(obj));   //81</span><br></pre></td></tr></table></figure></li></ul><p>虽然三个输出的都是81，但是 bind() 方法的后面多了对括号。也就是说，区别是当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。</p><h5 id="什么是闭包，闭包的用途是什么？"><a href="#什么是闭包，闭包的用途是什么？" class="headerlink" title="什么是闭包，闭包的用途是什么？"></a>什么是闭包，闭包的用途是什么？</h5><p>概念：<br>当我们需要得到函数内的局部变量时，就要在函数的内部，再定义一个函数。闭包就是能够读取函数内部变量的函数。</p><p>用处</p><ul><li>可以读取函数内部的变量</li><li>让变量的值始终保持在内存中。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　function a()&#123;</span><br><span class="line">　　　　var n=1;</span><br><span class="line">　　　　function b()&#123;  //这里的b就是一个闭包</span><br><span class="line">　　　　　　alert(n); </span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return b;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var result=a();</span><br><span class="line">　　result(); // 1</span><br></pre></td></tr></table></figure><p>上面代码中函数b就是一个闭包，从运行结果来看，函数b可以读取a的局部变量n。正好诠释了上面<strong>“闭包就是能够读取函数内部变量的函数”</strong>这一句话。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;请写出一个符合-W3C-规范的-HTML-文件，要求：&quot;&gt;&lt;a href=&quot;#请写出一个符合-W3C-规范的-HTML-文件，要求：&quot; class=&quot;headerlink&quot; title=&quot;请写出一个符合 W3C 规范的 HTML 文件，要求：&quot;&gt;&lt;/a&gt;请写出一个
      
    
    </summary>
    
      <category term="其它" scheme="http://yoursite.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="其它" scheme="http://yoursite.com/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>实现一个jQuery的API</title>
    <link href="http://yoursite.com/2018/01/12/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAjQuery%E7%9A%84API/"/>
    <id>http://yoursite.com/2018/01/12/实现一个jQuery的API/</id>
    <published>2018-01-12T06:39:25.000Z</published>
    <updated>2018-01-12T06:42:38.228Z</updated>
    
    <content type="html"><![CDATA[<h5 id="实现一个jQuery的API"><a href="#实现一个jQuery的API" class="headerlink" title="实现一个jQuery的API"></a>实现一个jQuery的API</h5><ul><li><p>传一个选择器或节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = function(nodeOrSelector) &#123; </span><br><span class="line">  let nodes = &#123;&#125;    </span><br><span class="line">  if (typeof nodeOrSelector === &quot;string&quot;) &#123;   </span><br><span class="line">    let temp = document.querySelectorAll(nodeOrSelector)</span><br><span class="line">    for (let i = 0; i &lt; temp.length; i++) &#123;   </span><br><span class="line">      nodes[i] = temp[i]     </span><br><span class="line">    &#125;</span><br><span class="line">    nodes.length = temp.length</span><br><span class="line">  &#125; else if (nodeOrSelector instanceof Node) &#123;</span><br><span class="line">    nodes = &#123;</span><br><span class="line">      0: nodeOrSelector,</span><br><span class="line">      length: 1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>为nodes添加类，并且遍历nodes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nodes.addClass = function(classes) &#123;</span><br><span class="line">   var classes = [classes] </span><br><span class="line">    classes.forEach((value) =&gt; &#123;</span><br><span class="line">      for (let i = 0; i &lt; nodes.length; i++) &#123; </span><br><span class="line">        nodes[i].classList.add(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历nodes，并且改变类的文本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  nodes.setText = function(text) &#123;</span><br><span class="line">    for (let i = 0; i &lt; nodes.length; i++) &#123; </span><br><span class="line">      nodes[i].textContent =text</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用API操作nodes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.$ = jQuery</span><br><span class="line">var $div = $(&apos;div&apos;) </span><br><span class="line">$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red</span><br><span class="line">$div.setText(&apos;hi&apos;) // 可将所有 div 的 textContent 变为 hi</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;a&quot;&gt;red&lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;b&quot;&gt;red&lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;c&quot;&gt;red&lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;d&quot;&gt;red&lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;e&quot;&gt;red&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.jQuery = function(nodeOrSelector) &#123;</span><br><span class="line">  let nodes = &#123;&#125;      //用nodes把节点和选择器都装起来</span><br><span class="line">  if (typeof nodeOrSelector === &quot;string&quot;) &#123;  //判断一下nodeOrSelector是节点还是一个选择器</span><br><span class="line">    let temp = document.querySelectorAll(nodeOrSelector)</span><br><span class="line">    for (let i = 0; i &lt; temp.length; i++) &#123;   //遍历所有的节点并且把它们都添加到nodes里</span><br><span class="line">      nodes[i] = temp[i]     </span><br><span class="line">    &#125;</span><br><span class="line">    nodes.length = temp.length</span><br><span class="line">  &#125; else if (nodeOrSelector instanceof Node) &#123;</span><br><span class="line">    nodes = &#123;</span><br><span class="line">      0: nodeOrSelector,</span><br><span class="line">      length: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nodes.addClass = function(classes) &#123;</span><br><span class="line">     var classes = [classes] </span><br><span class="line">      classes.forEach((value) =&gt; &#123;</span><br><span class="line">        for (let i = 0; i &lt; nodes.length; i++) &#123;   //遍历nodes</span><br><span class="line">          nodes[i].classList.add(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  nodes.setText = function(text) &#123;</span><br><span class="line">    for (let i = 0; i &lt; nodes.length; i++) &#123; </span><br><span class="line">      nodes[i].textContent =text</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nodes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.$ = jQuery</span><br><span class="line">var $div = $(&apos;div&apos;) </span><br><span class="line">$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red</span><br><span class="line">$div.setText(&apos;hi&apos;) // 可将所有 div 的 textContent 变为 hi</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;实现一个jQuery的API&quot;&gt;&lt;a href=&quot;#实现一个jQuery的API&quot; class=&quot;headerlink&quot; title=&quot;实现一个jQuery的API&quot;&gt;&lt;/a&gt;实现一个jQuery的API&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;传一个选择器或节点&lt;/p&gt;
      
    
    </summary>
    
      <category term="jQuery" scheme="http://yoursite.com/categories/jQuery/"/>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>Javascript操作DOM常用API总结</title>
    <link href="http://yoursite.com/2018/01/06/Javascript%E6%93%8D%E4%BD%9CDOM%E5%B8%B8%E7%94%A8API%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/06/Javascript操作DOM常用API总结/</id>
    <published>2018-01-06T03:40:59.000Z</published>
    <updated>2018-01-06T04:16:52.740Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://luopq.com/2015/11/30/javascript-dom/" target="_blank" rel="external">http://luopq.com/2015/11/30/javascript-dom/</a></p><p>文本整理了javascript操作DOM的一些常用的api，根据其作用整理成为创建，修改，查询等多种类型的api，主要用于复习基础知识，加深对原生js的认识。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在讲解操作DOM的api之前，首先我们来复习一下一些基本概念，这些概念是掌握api的关键，必须理解它们。</p><h4 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h4><p>DOM1级定义了一个Node接口，该接口由DOM中所有节点类型实现。这个Node接口在JS中是作为Node类型实现的。在IE9以下版本无法访问到这个类型，JS中所有节点都继承自Node类型，都共享着相同的基本属性和方法。<br>Node有一个属性nodeType表示Node的类型，它是一个整数，其数值分别表示相应的Node类型，具体如下：</p><ul><li>Node.element_node:1</li><li>Node.attribute_node:2</li><li>Node.text_node:3</li><li>Node.cdata_section_node:4</li><li>Node.entity_reference_node:5</li><li>Node.entity_node:6</li><li>Node.precessing_instruction_node:7</li><li>Node.comment_node:8</li><li>Node.document_node:9</li><li>Node.document_type_node:10</li><li>Node.document_fragment_node:11</li><li>Node.notation_node:12<br>假设我们要判断一个Node是不是元素，我们可以这样判断<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(someNode.nodeType==1)&#123;</span><br><span class="line">  console.log(&quot;Node is a element&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这些Node类型中，我们最常用的就是element，text，attribute，comment，document，document_fragment这几种类型。<br>我们简单来介绍一下这几种类型：</p><h6 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h6><p>Element提供了对元素标签名，子节点和特性的访问，我们常用HTML元素比如div，span，a等标签就是element中的一种。Element有下面几条特性：<br>（1）nodeType为1<br>（2）nodeName为元素标签名，tagName也是返回标签名<br>（3）nodeValue为null<br>（4）parentNode可能是Document或Element<br>（5）子节点可能是Element，Text，Comment，Processing_Instruction，CDATASection或EntityReference</p><h6 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h6><p>Text表示文本节点，它包含的是纯文本内容，不能包含html代码，但可以包含转义后的html代码。Text有下面的特性：<br>（1）nodeType为3<br>（2）nodeName为#text<br>（3）nodeValue为文本内容<br>（4）parentNode是一个Element<br>（5）没有子节点</p><h6 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h6><p>Attr类型表示元素的特性，相当于元素的attributes属性中的节点，它有下面的特性：<br>（1）nodeType值为2<br>（2）nodeName是特性的名称<br>（3）nodeValue是特性的值<br>（4）parentNode为null</p><h6 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h6><p>Comment表示HTML文档中的注释，它有下面的几种特征：<br>（1）nodeType为8<br>（2）nodeName为#comment<br>（3）nodeValue为注释的内容<br>（4）parentNode可能是Document或Element<br>（5）没有子节点</p><h6 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h6><p>Document表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个页面，它同时也是window对象的一个属性。Document有下面的特性：<br>（1）nodeType为9<br>（2）nodeName为#document<br>（3）nodeValue为null<br>（4）parentNode为null<br>（5）子节点可能是一个DocumentType或Element</p><h6 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h6><p>DocumentFragment是所有节点中唯一一个没有对应标记的类型，它表示一种轻量级的文档，可能当作一个临时的仓库用来保存可能会添加到文档中的节点。DocumentFragment有下面的特性：<br>（1）nodeType为11<br>（2）nodeName为#document-fragment<br>（3）nodeValue为null<br>（4）parentNode为null</p><p>我们简单地介绍了几种常见的Node类型，要记住，HTML中的节点并不只是包括元素节点，它还包括文本节点，注释节点等等。在这里我们只是简单地说明了几种常见的节点，想要进一步学习的同学可以查找一下相关资料。</p><h4 id="节点创建型api"><a href="#节点创建型api" class="headerlink" title="节点创建型api"></a>节点创建型api</h4><p>在这里，我将常用的DOM操作api进行分类，首先要介绍的是创建型的api。这一类型的api，简而言之就是用来创建节点的。</p><h5 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h5><p>createElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签。<br>使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var div = document.createElement(&quot;div&quot;);</span><br></pre></td></tr></table></figure></p><p>使用createElement要注意：通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中。</p><h5 id="cloneNode"><a href="#cloneNode" class="headerlink" title="cloneNode"></a>cloneNode</h5><p>cloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素，使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var parent = document.getElementById(&quot;parentElement&quot;); </span><br><span class="line">var parent2 = parent.cloneNode(true);// 传入true</span><br><span class="line">parent2.id = &quot;parent2&quot;;</span><br></pre></td></tr></table></figure></p><p>这段代码通过cloneNode复制了一份parent元素，其中cloneNode的参数为true，表示parent的子节点也被复制，如果传入false，则表示只复制了parent节点。<br>我们看看这个<a href="http://runjs.cn/detail/s2yelqet" target="_blank" rel="external">例子</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">    我是父元素的文本</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">        我是子元素</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;button id=&quot;btnCopy&quot;&gt;复制&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">var parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">document.getElementById(&quot;btnCopy&quot;).onclick = function()&#123;</span><br><span class="line">var parent2 = parent.cloneNode(true);</span><br><span class="line">parent2.id = &quot;parent2&quot;;</span><br><span class="line">document.body.appendChild(parent2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码很简单，主要是绑定button事件，事件内容是复制了一个parent，修改其id，然后添加到文档中。<br>这里有几点要注意：<br>（1）和createElement一样，cloneNode创建的节点只是游离有html文档外的节点，要调用appendChild方法才能添加到文档树中<br>（2）如果复制的元素有id，则其副本同样会包含该id，由于id具有唯一性，所以在复制节点后必须要修改其id<br>（3）调用接收的bool参数最好传入，如果不传入该参数，不同浏览器对其默认值的处理可能不同</p><p>除此之外，我们还有一个需要注意的点：<br>如果被复制的节点绑定了事件，则副本也会跟着绑定该事件吗？这里要分情况讨论：<br>（1）如果是通过addEventListener或者比如onclick进行绑定事件，则副本节点不会绑定该事件<br>（2）如果是内联方式绑定比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onclick=&quot;showParent()&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这样的话，副本节点同样会触发事件。</p><h5 id="createDocumentFragment"><a href="#createDocumentFragment" class="headerlink" title="createDocumentFragment"></a>createDocumentFragment</h5><p>createDocumentFragment方法用来创建一个DocumentFragment。在前面我们说到DocumentFragment表示一种轻量级的文档，它的作用主要是存储临时的节点用来准备添加到文档中。<br>createDocumentFragment方法主要是用于添加大量节点到文档中时会使用到。假设要循环一组数据，然后创建多个节点添加到文档中，比如<a href="http://runjs.cn/detail/nu4wptvl" target="_blank" rel="external">示例</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;添加多项&quot; id=&quot;btnAdd&quot; /&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;btnAdd&quot;).onclick = function()&#123;</span><br><span class="line">var list = document.getElementById(&quot;list&quot;);</span><br><span class="line">for(var i = 0;i &lt; 100; i++)&#123;</span><br><span class="line">var li = document.createElement(&quot;li&quot;);</span><br><span class="line">li.textContent = i;</span><br><span class="line">list.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码将按钮绑定了一个事件，这个事件创建了100个li节点，然后依次将其添加HTML文档中。这样做有一个缺点：每次一创建一个新的元素，然后添加到文档树中，这个过程会造成浏览器的回流。所谓回流简单说就是指元素大小和位置会被重新计算，如果添加的元素太多，会造成性能问题。这个时候，就是使用createDocumentFragment了。<br>DocumentFragment不是文档树的一部分，它是保存在内存中的，所以不会造成回流问题。我们修改上面的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;btnAdd&quot;).onclick = function()&#123;</span><br><span class="line">var list = document.getElementById(&quot;list&quot;);</span><br><span class="line">var fragment = document.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">for(var i = 0;i &lt; 100; i++)&#123;</span><br><span class="line">  var li = document.createElement(&quot;li&quot;);</span><br><span class="line">li.textContent = i;</span><br><span class="line">fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.appendChild(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优化后的代码主要是创建了一个fragment，每次生成的li节点先添加到fragment，最后一次性添加到list，大家可以看<a href="http://runjs.cn/detail/nu4wptvl" target="_blank" rel="external">示例</a></p><h5 id="创建型API总结"><a href="#创建型API总结" class="headerlink" title="创建型API总结"></a>创建型API总结</h5><p>创建型api主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点：<br>（1）它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中<br>（2）cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题<br>（3）使用createDocumentFragment来解决添加大量节点时的性能问题</p><h4 id="页面修改型API"><a href="#页面修改型API" class="headerlink" title="页面修改型API"></a>页面修改型API</h4><p>前面我们提到创建型api，它们只是创建节点，并没有真正修改到页面内容，而是要调用appendChild来将其添加到文档树中。我在这里将这类会修改到页面内容归为一类。<br>修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild。</p><p>#####appendChild</p><p>appendChild我们在前面已经用到多次，就是将指定的节点添加到调用该方法的节点的子元素的末尾。调用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.appendChild(child);</span><br></pre></td></tr></table></figure></p><p>child节点将会作为parent节点的最后一个子节点。<br>appendChild这个方法很简单，但是还有有一点需要注意：如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点，也就是说不会同时存在两个该节点在页面上，相当于把这个节点移动到另一个地方。我们来看<a href="http://runjs.cn/detail/kk3bodpw" target="_blank" rel="external">例子</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;child&quot;&gt;</span><br><span class="line">    要被添加的节点</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">    要移动的位置</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;input id=&quot;btnMove&quot; type=&quot;button&quot; value=&quot;移动节点&quot; /&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;btnMove&quot;).onclick = function()&#123;</span><br><span class="line">var child = document.getElementById(&quot;child&quot;);</span><br><span class="line">document.getElementById(&quot;parent&quot;).appendChild(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码主要是获取页面上的child节点，然后添加到指定位置，可以看到原本的child节点被移动到parent中了。<br>这里还有一个要注意的点：如果child绑定了事件，被移动时，它依然绑定着该事件。</p><h5 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h5><p>insertBefore用来添加一个节点到一个参照节点之前，用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentNode.insertBefore(newNode,refNode);</span><br></pre></td></tr></table></figure></p><p>parentNode表示新节点被添加后的父节点<br>newNode表示要添加的节点<br>refNode表示参照节点，新节点会添加到这个节点之前<br>我们来看这个<a href="http://runjs.cn/detail/p2rs1tmy" target="_blank" rel="external">例子</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">    父节点</span><br><span class="line">    &lt;div id=&quot;child&quot;&gt;</span><br><span class="line">        子元素</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;insertNode&quot; value=&quot;插入节点&quot; /&gt;</span><br><span class="line"></span><br><span class="line">var parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">var child = document.getElementById(&quot;child&quot;);</span><br><span class="line">document.getElementById(&quot;insertNode&quot;).onclick = function()&#123;</span><br><span class="line">var newNode = document.createElement(&quot;div&quot;);</span><br><span class="line">newNode.textContent = &quot;新节点&quot;</span><br><span class="line">parent.insertBefore(newNode,child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码创建了一个新节点，然后添加到child节点之前。<br>和appendChild一样，如果插入的节点是页面上的节点，则会移动该节点到指定位置，并且保留其绑定的事件。</p><p>关于第二个参数参照节点还有几个注意的地方：<br>（1）refNode是必传的，如果不传该参数会报错<br>（2）如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾</p><h5 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild"></a>removeChild</h5><p>removeChild顾名思义，就是删除指定的子节点并返回，用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var deletedChild = parent.removeChild(node);</span><br></pre></td></tr></table></figure></p><p>deletedChild指向被删除节点的引用，它等于node，被删除的节点仍然存在于内存中，可以对其进行下一步操作。<br>注意：如果被删除的节点不是其子节点，则程序将会报错。我们可以通过下面的方式来确保可以删除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(node.parentNode)&#123;</span><br><span class="line">    node.parentNode.removeChild(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过节点自己获取节点的父节点，然后将自身删除。</p><h5 id="replaceChild"><a href="#replaceChild" class="headerlink" title="replaceChild"></a>replaceChild</h5><p>replaceChild用于使用一个节点替换另一个节点，用法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.replaceChild(newChild,oldChild);</span><br></pre></td></tr></table></figure></p><p>newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置<br>oldChild是被替换的节点</p><h5 id="页面修改型API总结"><a href="#页面修改型API总结" class="headerlink" title="页面修改型API总结"></a>页面修改型API总结</h5><p>页面修改型api主要是这四个接口，要注意几个特点：<br>（1）不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置<br>（2）节点本身绑定的事件会不会消失，会一直保留着。</p><h4 id="节点查询型API"><a href="#节点查询型API" class="headerlink" title="节点查询型API"></a>节点查询型API</h4><p>节点查询型API也是非常常用的api，下面我们分别说明一下每一个api的使用。</p><h5 id="document-getElementById"><a href="#document-getElementById" class="headerlink" title="document.getElementById"></a>document.getElementById</h5><p>这个接口很简单，根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null。<br>使用这个接口有几点要注意：<br>（1）元素的Id是大小写敏感的，一定要写对元素的id<br>（2）HTML文档中可能存在多个id相同的元素，则返回第一个元素<br>（3）只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的</p><h5 id="document-getElementsByTagName"><a href="#document-getElementsByTagName" class="headerlink" title="document.getElementsByTagName"></a>document.getElementsByTagName</h5><p>这个接口根据元素标签名获取元素，返回一个即时的HTMLCollection类型，什么是即时的HTMLCollection类型呢？我们来看看这个<a href="http://runjs.cn/detail/13jvrs9t" target="_blank" rel="external">示例</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;div1&lt;/div&gt;</span><br><span class="line">&lt;div&gt;div2&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;显示数量&quot; id=&quot;btnShowCount&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;新增div&quot; id=&quot;btnAddDiv&quot;/&gt;</span><br><span class="line"></span><br><span class="line">var divList = document.getElementsByTagName(&quot;div&quot;);</span><br><span class="line">document.getElementById(&quot;btnAddDiv&quot;).onclick = function()&#123;</span><br><span class="line">var div = document.createElement(&quot;div&quot;);</span><br><span class="line">div.textContent =&quot;div&quot; + (divList.length+1);</span><br><span class="line">document.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;btnShowCount&quot;).onclick = function()&#123;</span><br><span class="line">        alert(divList.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码中有两个按钮，一个按钮是显示HTMLCollection元素的个数，另一个按钮可以新增一个div标签到文档中。前面提到HTMLCollcetion元素是即时的表示该集合是随时变化的，也就是是文档中有几个div，它会随时进行变化，当我们新增一个div后，再访问HTMLCollection时，就会包含这个新增的div。<br>使用document.getElementsByTagName这个方法有几点要注意：<br>（1）如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率<br>（2）如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection<br>（3）“*”表示所有标签</p><h5 id="document-getElementsByName"><a href="#document-getElementsByName" class="headerlink" title="document.getElementsByName"></a>document.getElementsByName</h5><p>getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象。<br>使用这个接口主要要注意几点：<br>（1）返回对象是一个即时的NodeList，它是随时变化的<br>（2）在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name属性，它也是可以被查找到的<br>（3）在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name</p><h5 id="document-getElementsByClassName"><a href="#document-getElementsByClassName" class="headerlink" title="document.getElementsByClassName"></a>document.getElementsByClassName</h5><p>这个API是根据元素的class返回一个即时的HTMLCollection，用法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var elements = document.getElementsByClassName(names);</span><br></pre></td></tr></table></figure></p><p>这个接口有下面几点要注意：<br>（1）返回结果是一个即时的HTMLCollection，会随时根据文档结构变化<br>（2）IE9以下浏览器不支持<br>（3）如果要获取2个以上classname，可传入多个classname，每个用空格相隔，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var elements = document.getElementsByClassName(&quot;test1 test2&quot;);</span><br></pre></td></tr></table></figure></p><h5 id="document-querySelector和document-querySelectorAll"><a href="#document-querySelector和document-querySelectorAll" class="headerlink" title="document.querySelector和document.querySelectorAll"></a>document.querySelector和document.querySelectorAll</h5><p>这两个api很相似，通过css选择器来查找元素，注意选择器要符合<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors" target="_blank" rel="external">CSS选择器</a>的规则。<br>首先来介绍一下document.querySelector。<br>document.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。<br>注意，由于返回的是第一个匹配的元素，这个api使用的深度优先搜索来获取元素。我们来看这个<a href="http://runjs.cn/detail/dl1uvbtq" target="_blank" rel="external">例子</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;span class=&quot;test&quot;&gt;第三级的span&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;test&quot;&gt;</span><br><span class="line">    同级的第二个div</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;获取test元素&quot; /&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;btnGet&quot;).addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">var element = document.querySelector(&quot;.test&quot;);</span><br><span class="line">alert(element.textContent);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这个例子很简单，就是两个class都包含“test”的元素，一个在文档树的前面，但是它在第三级，另一个在文档树的后面，但它在第一级，通过querySelector获取元素时，它通过深度优先搜索，拿到文档树前面的第三级的元素。</p><p>document.querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符，我们来看看下面这个<a href="http://runjs.cn/detail/egu0tjoj" target="_blank" rel="external">例子</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;test&quot;&gt;</span><br><span class="line">    class为test</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;test&quot;&gt;</span><br><span class="line">    id为test</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;input id=&quot;btnShow&quot; type=&quot;button&quot; value=&quot;显示内容&quot; /&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;btnShow&quot;).addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">var elements = document.querySelectorAll(&quot;#test,.test&quot;);</span><br><span class="line">for(var i = 0,length = elements.length;i&lt;length;i++)&#123;</span><br><span class="line">alert(elements[i].textContent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这段代码通过querySelectorAll，使用id选择器和class选择器选择了两个元素，并依次输出其内容。要注意两点：<br>（1）querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关<br>（2）返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化</p><p>兼容性问题：querySelector和querySelectorAll在ie8以下的浏览器不支持。</p><h5 id="节点关系型api"><a href="#节点关系型api" class="headerlink" title="节点关系型api"></a>节点关系型api</h5><p>在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等，下面我们依次来看看每一种关系。</p><h5 id="父关系型api"><a href="#父关系型api" class="headerlink" title="父关系型api"></a>父关系型api</h5><p>parentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。<br>parentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null</p><h5 id="兄弟关系型api"><a href="#兄弟关系型api" class="headerlink" title="兄弟关系型api"></a>兄弟关系型api</h5><p>previousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。<br>previousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。</p><p>nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。<br>nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。</p><h5 id="子关系型api"><a href="#子关系型api" class="headerlink" title="子关系型api"></a>子关系型api</h5><p>childNodes：返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。<br>children：一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。<br>firstNode：第一个子节点<br>lastNode：最后一个子节点<br>hasChildNodes方法：可以用来判断是否包含子节点。</p><h5 id="元素属性型api"><a href="#元素属性型api" class="headerlink" title="元素属性型api"></a>元素属性型api</h5><p>setAttribute</p><p>setAttribute：根据名称和值修改元素的特性，用法如下。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.setAttribute(name, value);</span><br></pre></td></tr></table></figure></p><p>其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。<br>如果元素本身包含指定的特性名为属性，则可以世界访问属性进行赋值，比如下面两条代码是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.setAttribute(&quot;id&quot;,&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">element.id = &quot;test&quot;;</span><br></pre></td></tr></table></figure></p><h5 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute"></a>getAttribute</h5><p>getAttribute返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串。用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var value = element.getAttribute(&quot;id&quot;);</span><br></pre></td></tr></table></figure></p><h4 id="元素样式型api"><a href="#元素样式型api" class="headerlink" title="元素样式型api"></a>元素样式型api</h4><p>window.getComputedStyle</p><p>window.getComputedStyle是用来获取应用到元素后的样式，假设某个元素并未设置高度而是通过其内容将其高度撑开，这时候要获取它的高度就要用到getComputedStyle，用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var style = window.getComputedStyle(element[, pseudoElt]);</span><br></pre></td></tr></table></figure></p><p>element是要获取的元素，pseudoElt指定一个伪元素进行匹配。<br>返回的style是一个CSSStyleDeclaration对象。<br>通过style可以访问到元素计算后的样式</p><h5 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h5><p>getBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置，用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var clientRect = element.getBoundingClientRect();</span><br></pre></td></tr></table></figure></p><p>clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等数据，具体可查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="external">链接</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要总结了原生js中常用的操作DOM的api接口，主要为了复习基础知识。平时开发用多了jQuery等类库，对基础知识的了解可能就渐渐地遗忘，但这些基础知识才是我们立足的根本，只有掌握原生的js，才能真正做好js的开发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;http://luopq.com/2015/11/30/javascript-dom/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://luopq.com/2015/11/30/javascript-dom/&lt;/a&gt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Js里的类型转换</title>
    <link href="http://yoursite.com/2018/01/01/Js%E9%87%8C%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/01/01/Js里的类型转换/</id>
    <published>2018-01-01T08:16:31.000Z</published>
    <updated>2018-01-01T08:28:05.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS里的类型"><a href="#JS里的类型" class="headerlink" title="JS里的类型"></a>JS里的类型</h3><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><ul><li>基本类型<br><code>number</code> <code>string</code> <code>boolean</code> <code>symbol</code> <code>null</code> <code>undefined</code> </li><li>复砸类型<br><code>object</code></li></ul><h5 id="转字符串string"><a href="#转字符串string" class="headerlink" title="转字符串string"></a>转字符串string</h5><ul><li>方法1：使用toString()转换字符串，如图<br><img src="http://upload-images.jianshu.io/upload_images/8532417-97e6f2b76dbca503.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/8532417-d4904b2aaac8a5c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图中可以看到，使用<code>toString()</code>方法把数据类型转换字符串，只有<code>number</code> <code>boolean</code> 可以转换成功，而<code>null</code>和<code>undefined</code> 则返回了一条<strong>Cannot read property ‘toString’ of null</strong> ，说明<code>null</code>和<code>undefined</code>无法使用toString()转换字符串，那么只能使用其它方法。</p><ul><li>方法2：使用 <code>+ &#39;&#39;</code>或<code>&#39;&#39; +</code> 转换字符串<strong>（推荐用此法来转换字符串）</strong>，如图<br><img src="http://upload-images.jianshu.io/upload_images/8532417-82cb876694ae939d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p>图中可以看到，不管是哪一种类型，即使是用toString()转换失败的<code>null</code>和<code>undefined</code>，只要用<code>+ &#39;&#39;</code>或<code>&#39;&#39; +</code>，都可以把所有的类型都转换成字符串。<code>+</code>号的作用是：如果发现左右任意一边有字符串，它就会自动把另一边也变成字符串。<br>其实这种方法还有一种经常我们会碰见的奇怪现象，如图中最后几行：<br>在运行<code>1+1</code>的时候，运行结果等于2，而运行<code>1+&#39;1&#39;</code>的时候，结果为”11”，其实<code>1+&#39;1&#39;</code>等价于<code>(1).toString()+&#39;1&#39;</code>,运行出来的结果即为”11”。</p><ul><li>方法3：使用全局方法<code>window.String()</code>，如图<br><img src="http://upload-images.jianshu.io/upload_images/8532417-82607f25c2ee9209.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p>这三种方法都是可以使用的，但是我比较推荐用第二种，方便很多。</p><h5 id="转boolean（记住五个falsy值）"><a href="#转boolean（记住五个falsy值）" class="headerlink" title="转boolean（记住五个falsy值）"></a>转boolean（记住五个falsy值）</h5><ul><li>方法1，一般用法，直接使用boolean转换，如图<br><img src="http://upload-images.jianshu.io/upload_images/8532417-4263f4d9d692654d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p>-方法2，推荐用法，直接用<code>!!</code>转换，如图<br><img src="http://upload-images.jianshu.io/upload_images/8532417-c944d77d8750a646.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>在js里面，其它的值转换成布尔的时候，有五个特殊的值需要记住的，分别为：</p><ul><li>number<blockquote><p>0=false<br>NaN=false</p><p>number除了这两个值为false外，其余均为true</p></blockquote></li><li>string<blockquote><p>‘’ =false</p><p>‘’ 为空字符串</p></blockquote></li><li>null <blockquote><p>null=false</p><p>null本身就为false</p></blockquote></li><li>undefined<blockquote><p>undefined=false</p><p>undefined本身就为false</p></blockquote></li></ul><p><code>0</code> <code>NaN</code> <code>&#39;&#39;</code> <code>null</code> <code>undefined</code>  这五个值均为falsy值(关于falsy可以查阅MDN文档了解)，除了这五个值以外，其余的值转成boolean都为true.<br>还有一个object类型，这个类型的boolean值全部都是true，包括array和function，都为true.</p><h5 id="转number"><a href="#转number" class="headerlink" title="转number"></a>转number</h5><ul><li>number(‘1’)===1</li><li>parseInt(‘1’,10)     全局函数</li><li>parsefloat(‘1.23’)===1.23</li><li>‘1’-0===1  推荐此法</li><li>+’1’ ===1或 +’-1’=== -1</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS里的类型&quot;&gt;&lt;a href=&quot;#JS里的类型&quot; class=&quot;headerlink&quot; title=&quot;JS里的类型&quot;&gt;&lt;/a&gt;JS里的类型&lt;/h3&gt;&lt;h5 id=&quot;类型转换&quot;&gt;&lt;a href=&quot;#类型转换&quot; class=&quot;headerlink&quot; title=&quot;类
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>工具以及一些学习网站</title>
    <link href="http://yoursite.com/2017/12/11/%E5%B7%A5%E5%85%B7%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2017/12/11/工具以及一些学习网站/</id>
    <published>2017-12-11T13:42:39.000Z</published>
    <updated>2018-01-13T13:53:15.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端开发需要用到的工具和浏览的网站实在是太多了，今天把这段时间收集的一些资料都整理好统一一下吧，以便自己日后方便查询。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li>VSCode安装：<a href="https://code.visualstudio.com/" target="_blank" rel="external">VSCode</a></li><li>Node.js安装：<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a></li><li>图片编辑软件：<a href="https://www.getpaint.net/" target="_blank" rel="external">paint.net</a></li></ol><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><ol><li><a href="https://upclinux.github.io/intro/07/vim-and-emacs/" target="_blank" rel="external">编辑器之神</a></li><li><a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="external">简明 vim 练级攻略</a></li><li><a href="https://vim-adventures.com/" target="_blank" rel="external">一个 vim 游戏</a></li><li><a href="https://explainshell.com/explain?cmd=ls+-lrt" target="_blank" rel="external">命令行释义</a></li><li><a href="https://github.com/tldr-pages/tldr#tldr" target="_blank" rel="external">命令行常见用法</a></li></ol><h2 id="macOS-命令行安装与配置"><a href="#macOS-命令行安装与配置" class="headerlink" title="macOS 命令行安装与配置"></a>macOS 命令行安装与配置</h2><ol><li><a href="http://yijiebuyi.com/blog/9c6419897949a7935d0fdec74cb7c61b.html" target="_blank" rel="external">安装 iTerm2</a></li><li><a href="http://yijiebuyi.com/blog/9c6419897949a7935d0fdec74cb7c61b.html" target="_blank" rel="external">配置</a></li></ol><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="external">SSH key原理与运用</a></li><li>README.md 的作用: <a href="http://www.jianshu.com/p/94406f5d9b46" target="_blank" rel="external">怎么给GitHub项目写一份易读的 README.md</a></li><li>LISENCE 的作用: <a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="external">如何选择开源许可证？</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html" target="_blank" rel="external">读懂 diff - 阮一峰</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="external">搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门</a></li><li><a href="http://www.runoob.com/git/git-install-setup.html" target="_blank" rel="external">Git 菜鸟教程</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743256916071d599b3aed534aaab22a0db6c4e07fd0000" target="_blank" rel="external">廖雪峰的 Git 教程</a></li></ol><h2 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP 传输控制协议"></a>TCP 传输控制协议</h2><ol><li><a href="https://www.nowcoder.com/questionTerminal/63c8b45c91a544bd8febc1f1ff02e3b5?toCommentId=73766" target="_blank" rel="external">TCP 和 UDP 的区别是什么</a></li><li><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="external">TCP 的三次握手指的是什么</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html" target="_blank" rel="external">深入了解TCP</a></li><li><a href="https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8#0.E5.88.B01023.E5.8F.B7.E7.AB.AF.E5.8F.A3" target="_blank" rel="external"> 0 到 1023 号端口</a></li></ol><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h4 id="我的建议是：中文学习资源只看大-V-的，英文资源看-CSS-Tricks、MDN-和-Codrops。书的话作用不大，最权威的书其实是文档。"><a href="#我的建议是：中文学习资源只看大-V-的，英文资源看-CSS-Tricks、MDN-和-Codrops。书的话作用不大，最权威的书其实是文档。" class="headerlink" title="我的建议是：中文学习资源只看大 V 的，英文资源看 CSS Tricks、MDN 和 Codrops。书的话作用不大，最权威的书其实是文档。"></a>我的建议是：中文学习资源只看大 V 的，英文资源看 CSS Tricks、MDN 和 Codrops。书的话作用不大，最权威的书其实是文档。</h4><ol><li>CSS一些好玩的小技巧：<a href="https://css-tricks.com/" target="_blank" rel="external">CSS-TRICKS</a></li><li><a href="http://www.ruanyifeng.com/blog/2010/03/css_cookbook.html" target="_blank" rel="external">阮一峰 CSS</a></li><li><a href="http://www.zhangxinxu.com/wordpress/category/css/page/25/" target="_blank" rel="external">张鑫旭的 240 多篇 CSS 博客</a></li><li><a href="https://tympanus.net/codrops/category/playground/" target="_blank" rel="external">Codrops 炫酷 CSS 效果</a></li><li>书单推荐：<a href="http://www.ituring.com.cn/book/1695" target="_blank" rel="external">CSS揭秘</a></li><li><a href="http://cndevdocs.com/" target="_blank" rel="external">CSS中文规范文档</a></li><li><a href="https://www.w3.org/Style/CSS/specs.en.html" target="_blank" rel="external">CSS英文规范文档</a></li><li>免费书在线：<a href="http://adamschwartz.co/magic-of-css/" target="_blank" rel="external">Magic of CSS</a></li><li>渐变生成：<a href="http://www.colorzilla.com/gradient-editor/" target="_blank" rel="external">Gradient Generator</a></li><li>阴影生成：<a href="https://www.cssmatic.com/box-shadow" target="_blank" rel="external">box-shadow</a></li></ol><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript只推荐两个</p><ol><li>书单：<code>JavaScript高级程序设计</code></li><li><a href="http://javascript.ruanyifeng.com/" target="_blank" rel="external">阮一峰javascript教程</a></li></ol><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><ol><li><a href="https://api.jquery.com/" target="_blank" rel="external">jQuery API文档</a> </li></ol><h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><ol><li><a href="https://docs.emmet.io/cheat-sheet/" target="_blank" rel="external">Emmet作弊表</a></li><li><a href="https://www.iplaysoft.com/top10-programming-fonts.html" target="_blank" rel="external">10大最适合编程的字体推荐下载</a></li><li><a href="http://bubkoo.com/tags/algorithm/" target="_blank" rel="external">各种数据算法</a></li><li><a href="https://visualgo.net/bn/sorting" target="_blank" rel="external">各种数据算法演示</a></li><li><a href="https://github.com/it-ebooks/it-ebooks-archive" target="_blank" rel="external">计算机开放电子书汇总</a></li></ol><h2 id="工具网站"><a href="#工具网站" class="headerlink" title="工具网站"></a>工具网站</h2><ol><li><a href="https://www.namesilo.com/index.php" target="_blank" rel="external">域名购买</a></li><li>设计网站：<a href="https://dribbble.com/" target="_blank" rel="external">dribbble.com</a></li><li><a href="http://www.iconfont.cn/" target="_blank" rel="external">阿里巴巴矢量图</a></li><li>超高清壁纸天堂：<a href="https://alpha.wallhaven.cc/" target="_blank" rel="external">wallhaven</a></li><li><a href="https://freebiesbug.com/psd-freebies/website-template/" target="_blank" rel="external">免费PSD网站设计模板</a></li><li><a href="http://compressjpeg.com/zh/" target="_blank" rel="external">在线压缩JPG图像</a></li><li>图片上传生成网址：<a href="https://sm.ms/" target="_blank" rel="external">Image Upload</a></li></ol><p>持续更新…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前端开发需要用到的工具和浏览的网站实在是太多了，今天把这段时间收集的一些资料都整理好统一一下吧，以便自己日后方便查询。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="其它" scheme="http://yoursite.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="其它" scheme="http://yoursite.com/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>Git操作手册</title>
    <link href="http://yoursite.com/2017/12/08/Git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2017/12/08/Git操作手册/</id>
    <published>2017-12-08T11:42:06.000Z</published>
    <updated>2017-12-08T14:04:45.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置-GitHub"><a href="#配置-GitHub" class="headerlink" title="配置 GitHub"></a>配置 GitHub</h2><ol><li>进入 <a href="https://github.com/settings/keys" target="_blank" rel="external">Github的SSH keys</a></li><li>如果页面里已经有一些 key，就点「delete」按钮把这些 key 全删掉。如果没有，就往下看</li><li>点击 <code>New SSH key</code>，你需要输入 <code>Title</code> 和 <code>Key</code>，但是你现在没有 key，往下看</li><li>打开 Git Bash</li><li>复制并运行 <code>rm -rf ~/.ssh/*</code> 把现有的 ssh key 都删掉，这句命令行如果你多打一个空格，可能就要重装系统了，建议复制运行。</li><li>运行 <code>ssh-keygen -t rsa -b 4096 -C &quot;你的邮箱&quot;</code>，注意填写你的邮箱！</li><li>按回车三次</li><li>运行 <code>cat ~/.ssh/id_rsa.pub</code>，得到一串东西，完整的复制这串东西</li><li>回到上面第 3 步的页面，在 Title 输入「我的第一个 key」</li><li>在 Key 里粘贴刚刚你你复制的那串东西</li><li>点击 Add SSH key</li><li>回到 Git Bash</li><li>运行 <code>ssh -T git@github.com</code>，你可能会看到这样的提示：<br><img src="http://m.qpic.cn/psb?/V149ONjw3gE9gi/3LZVyvPnF6SLNoH7v*ZX7jfyUVVOdlfjTf594lXOJv0!/b/dPIAAAAAAAAA&amp;bo=ZAN4AAAAAAARBy8!&amp;rf=viewer_4" alt="img"><br>输入 <code>yes</code> 回车……问你话你就答，别傻在那</li><li>然后如果你看到 <code>Permission denied (publickey)</code>. 就说明你失败了，请回到第 1 步重来，是的，回到第 1 步重来；如果你看到 <code>Hi FrankFang! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code> 就说明你成功了！<br>好了，终于 TMD 添加了一个无聊的 SSH key，不要问我这个有什么用，因为一会儿你就会用到它，你想了解原理就看这篇<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="external">文章</a></li></ol><p>如果要讲清楚，太浪费时间了，我们只是想用用 GitHub 而已。</p><ul><li>一台电脑只需要一个 SSH key</li><li>一个 SSH key 可以访问你的所有仓库，即使你有 1000000 个仓库，都没问题</li><li>如果你新买了电脑，就在新电脑上重新生成一个 SSH key，把这个 key 也上传到 GitHub，它可以和之前的 key 共存在 GitHub 上</li><li>如果你把 key 从电脑上删除了，重新生成一个 key 即可，替换之前的 key</li></ul><h2 id="配置-git"><a href="#配置-git" class="headerlink" title="配置 git"></a>配置 git</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="comment">//user.name改为你的英文名</span></span><br><span class="line">git config --global user.email <span class="comment">//user.email你的邮箱</span></span><br><span class="line">git config --global push.default matching</span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line">git config --global core.editor <span class="string">"vim"</span></span><br></pre></td></tr></table></figure><p>五句话，依次运行。不执行的话，电脑可能会爆炸你信不信。</p><h2 id="使用-git"><a href="#使用-git" class="headerlink" title="使用 git"></a>使用 git</h2><p>使用 git 有三种方式，请按照你的需求选择</p><ul><li>只在本地使用</li><li>将本地仓库上传到 GitHub</li><li>下载 GitHub 上的仓库</li></ul><h2 id="1-只在本地使用"><a href="#1-只在本地使用" class="headerlink" title="1.只在本地使用"></a>1.只在本地使用</h2><h3 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h3><ol><li>创建目录作为我们的项目目录：<code>mkdir git-demo-2</code></li><li>进入目录 <code>cd git-demo-2</code></li><li><code>git init</code>，这句命令会在 git-demo-1 里创建一个 <code>.git</code> 目录</li><li><code>ls -la</code> 你就会看到 .git 目录，它就是一个「仓库」，<strong>不要进去看，这仓库里面有毒，别进去！</strong></li><li>在 git-demo-1 目录里面添加任意文件，假设我们添加了两个文件，分别是 index.html 和 css/style.css<blockquote><p><code>touch index.html</code><br><code>mkdir css</code><br><code>touch css/style.css</code></p></blockquote></li><li>运行 <code>git status -sb</code> 可以看到文件前面有 ?? 号<blockquote><p>##Initial commit on master<br>?? css/<br>?? index.html</p></blockquote></li></ol><p>这个 ?? 表示 git 一脸懵逼，不知道你要怎么对待这些变动。</p><ol><li>使用 <code>git add</code> 将文件添加到「暂存区」</li></ol><ul><li>你可以一个一个地 add<blockquote><p>git add index.html<br>git add css/style.css</p></blockquote></li><li>你也可以一次性 add<blockquote><p><code>git add .</code> 意思是把当前目录（.表示当前目录）里面的变动都加到「暂存区」</p></blockquote></li></ul><ol><li>再次运行 <code>git status -sb</code>，可以看到 <code>??</code> 变成了 <code>A</code><blockquote><p>##Initial commit on master<br>A  css/style.css<br>A  index.html</p></blockquote></li></ol><p>A 的意思就是添加，也就是说你告诉 git，这些文件我要加到仓库里</p><ol><li>使用 <code>git commit -m &quot;信息&quot;</code> 将你 add 过的内容「正式提交」到本地仓库（.git就是本地仓库），并添加一些注释信息，方便日后查阅</li></ol><ul><li>你可以一个一个地 <code>commit</code><blockquote><p>git commit index.html -m ‘添加index.html’<br>git commit css/style.css -m “添加 css/style.css”</p></blockquote></li><li>你也可以一次性<code>commit</code><blockquote><p>git commit . -m “添加了几个文件”</p></blockquote></li></ul><ol><li>再再次运行 <code>git status -sb</code>，发现没有文件变动了，这是因为文件的变动已经记录在仓库里了。<br>这时你使用 <code>git log</code> 就可以看到历史上的变动：<blockquote><p>commit f0d95058cd32a332b98967f6c0a701c64a00810a<br>Author: phoebechoi <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x70;&#x68;&#x6f;&#x65;&#x62;&#x65;&#99;&#104;&#111;&#x69;&#x2e;&#x69;&#115;&#109;&#101;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;">&#x70;&#x68;&#x6f;&#x65;&#x62;&#x65;&#99;&#104;&#111;&#x69;&#x2e;&#x69;&#115;&#109;&#101;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;</a><br>Date:   Thu Sep 28 22:30:43 2017 +0800</p><p>添加几个文件</p></blockquote></li><li>以上就是 <code>git add / git commit</code> 的一次完整过程，可以看到，挺复杂的。原则上，错了任何一步，都从头来一遍，做到你不会再手抖为止。</li></ol><h3 id="1-2-文件变动"><a href="#1-2-文件变动" class="headerlink" title="1.2 文件变动"></a>1.2 文件变动</h3><p>如果我想继续改文件，应该怎么做呢？</p><ol><li><code>start css/style.css</code> 会使用默认的编辑器打开 css/style.css（macOS 上对应的命令是 <code>open css/style.css</code>）</li><li>然后我们在 <code>css/style.css</code> 里写入 <code>body {background: red}</code>，保存退出</li><li>运行 <code>git status -sb</code> 发现提示中有一个 <code>M</code><blockquote><p>##master<br>M css/style.css</p></blockquote></li></ol><p>这个 M 的意思就是 Modified，表示这个文件被修改了</p><ol><li>此时你如果想让改动保存到仓库里，你需要先 <code>git add css/style.css</code> 或者也可以<code>git add .</code><br>注意，由于这个 css/style.css 以前被我们 add 过，你往文章上面看，我们是 add 过 css/style.css 的，所以此处的 git add 操作可以省略，但我建议你使用 git 的前一个月，不要省略 <code>git add</code>。<br>换句话说，每一次改动，都要经过 <code>git add</code> 和 <code>git commit</code> 两个命令，才能被添加到 .git 本地仓库里。</li><li>再次运行 <code>git status -sb</code> 发现 M 由红色变成了绿色，红色和绿色有啥区别呢？别管它们的区别，记住我说的，先 <code>add</code>，再 <code>commit</code>，等你熟练之后再去理解区别。<br>先形成肌肉记忆，在去形成大脑记忆！</li><li>运行 <code>git commit -m &quot;更新 css/style.css&quot;</code>，这个改动就被提交到 <code>.git</code> 本地仓库了。再说一次，不要去 .git 目录里面，那里的东西你一无所知。</li><li>再再次运行 <code>git status -sb</code>，会发现没有变更了，这说明所有变动都被本地仓库记录在案了。<br>这里来透露一下 <code>git status -sb</code> 是什么意思：<code>git status</code> 是用来显示当前的文件状态的，哪个文件变动了，方便你进行 git add 操作。-sb 选项的意思就是，SB都能看懂，哈，这是开玩笑，-s 的意思是显示总结（summary），-b 的意思是显示分支（branch），所以 -sb 的意思是显示总结和分支。</li></ol><h3 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h3><p>至此，我们来总结一下用到的命令</p><ol><li><code>git init</code>，初始化本地仓库 .git</li><li><code>git status -sb</code>，显示当前所有文件的状态</li><li><code>git add 文件路径</code>，用来将变动加到暂存区</li><li><code>git commit -m &quot;信息&quot;</code>，用来正式提交变动，提交至 .git 仓库</li><li>如果有新的变动，我们只需要依次执行 <code>git add xxx</code> 和 <code>git commit -m &#39;xxx&#39;</code> 两个命令即可。别看本教程废话那么多，其实就这一句有用！先 <code>add</code> 再 <code>commit</code>，行了，你学会 git 了。</li><li><code>git log</code> 查看变更历史</li></ol><h2 id="2-将本地仓库上传到-GitHub"><a href="#2-将本地仓库上传到-GitHub" class="headerlink" title="2 将本地仓库上传到 GitHub"></a>2 将本地仓库上传到 GitHub</h2><p>如何将我们这个 git-demo-2 上传到 GitHub 呢？</p><ol><li>在 GitHub 上新建一个空仓库，名称随意，一般可以跟本地目录名一致，也叫做 git-demo-2<br><img src="http://m.qpic.cn/psb?/V149ONjw3gE9gi/0EC*P2BUYiprfXPIwFHrvUcMppW63XdVNJvX.Ca*lXo!/b/dPMAAAAAAAAA&amp;bo=KQMJAgAAAAARBxE!&amp;rf=viewer_4" alt="img"><br>按照截图所示，除了仓库名，<strong>其他的什么都别改，其他的什么都别改，其他的什么都别改，其他的什么都别改</strong>，这样你才能创建一个空仓库</li><li>点击创建按钮之后，GitHub 就会把后续的操作全告诉你，如图<br><img src="http://m.qpic.cn/psb?/V149ONjw3gE9gi/nVWySS2tZlU9LJpKlanWyOOhU4UvBWuU4WukMF*Pd7s!/b/dPMAAAAAAAAA&amp;bo=mAM4AgAAAAARB5E!&amp;rf=viewer_4" alt="img"></li><li>看图，<strong>点击 SSH 按钮，点击 SSH 按钮，点击 SSH 按钮</strong>，我想你现在肯定不会忘了点击 SSH 按钮了吧~~~~如果不点击这个按钮，你就会使用默认的 HTTPS 地址。但是千万不要使用 HTTPS 地址，因为 HTTPS 地址使用起来特别麻烦，每次都要输入密码，而 SSH 不用输入用户名密码。<br>为什么 SSH 不用密码呢，因为你已经上传了 SSH public key。</li><li>由于我们已经有本地仓库了，所以看图，图中下面半部分就是你需要的命令，我们一行一行拷贝过来执行</li></ol><ul><li>找到图中的「…or push an existing repository from the command line」这一行，你会看到 <code>git remote add origin https://github.com/xxxxxxxxxx/git-demo-1.git</code>， 如果你发现这个地址是 https 开头的，那你就做错了，还记得吗，我们要使用 SSH 地址，GitHub 的 SSH 地址是以 git@github.com 开头的。</li><li>再次点击 SSH 按钮，不管我强调多少遍，总会有人忘记点击 SSH 按钮，为什么呢？我也不知道，为了防止你忘了点击 SSH 按钮，我最后再说一遍，<code>「点击 SSH按钮」</code>，点击之后，整个世界就会变得美好起来。</li><li>得到新的命令 <code>git remote add origin git@github.com:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/git-demo-1.git</code>，复制并运行它</li><li>复制第二行 <code>git push -u origin master</code>，运行它</li><li>刷新当前页面，你的仓库就上传到 GitHub 了！是不是特别简单？只要你按照我说的做，一丝不苟，即可。</li></ul><h2 id="3-直接在-GitHub-创建一个仓库，然后下载到本地"><a href="#3-直接在-GitHub-创建一个仓库，然后下载到本地" class="headerlink" title="3 直接在 GitHub 创建一个仓库，然后下载到本地"></a>3 直接在 GitHub 创建一个仓库，然后下载到本地</h2><p>上面两步讲了</p><blockquote><ul><li>在本地创建仓库</li><li>将本地仓库上传到 GitHub</li></ul></blockquote><p>这里有第三种用法，那就是直接在 GitHub 创建一个仓库，然后下载到本地。</p><ol><li>在GitHub 上新建一个仓库 git-demo-3，这次就不创建空仓库了，而是自带 README 和 Lisence 的仓库，创建截图如下：<br><img src="http://a3.qpic.cn/psb?/V149ONjw3gE9gi/Ebt*P*cdSj4*8khV1GDf1oQR8dNiLmWTiaLltSvnOww!/b/dPIAAAAAAAAA&amp;bo=LANGAiwDRgIRADc!&amp;rf=viewer_4" alt="img"><br>请按图中所示，填写一模一样的内容，然后点击创建按钮。</li><li>这样一来，这个仓库就会自动拥有两个文件（有些人可能会有三个文件，还有一个文件是<code>.gitignore</code>）：<br><img src="http://a1.qpic.cn/psb?/V149ONjw3gE9gi/QnZBXJpzU0RXt0iUFKk1x*td560VsSucbAYcXVUJ1Bk!/b/dPMAAAAAAAAA&amp;bo=iwNCAosDQgIRADc!&amp;rf=viewer_4" alt="img"></li><li>这两个文件的作用请自行了解：<a href="http://www.jianshu.com/p/94406f5d9b46" target="_blank" rel="external">README.md</a> 的作用 以及 <a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="external">LISENCE</a> 的作用</li><li>好了，现在远程仓库已经创建好了，怎么下载到我们的本地（也就是我们的电脑上）呢？答案是使用 git clone 命令</li><li><p>点击页面中唯一的绿色按钮「clone or download」，会看到一个弹出层<br><img src="http://a1.qpic.cn/psb?/V149ONjw3gE9gi/wfmWIp8H0*T5lMuoSe6noM2vvQM3hBAHOTMFfuSIsKs!/b/dPMAAAAAAAAA&amp;bo=wwELAQAAAAARAP8!&amp;rf=viewer_4" alt="img"></p></li><li><p>请确保弹出层里的地址是 SSH 地址，也就是 git@github.com 开头的地址，如果不是，就点击 Use SSH 按钮，就点击 Use SSH 按钮，就点击 Use SSH 按钮。然后复制这个地址。</p></li><li>打开 Git Bash，找一个安全的目录，比如 ~/Desktop 桌面目录就很安全：<code>cd ~/Desktop</code>。运行。</li><li>运行 <code>git clone 你刚才得到的以git@github.com开头的地址</code>，运行完了你就会发现，桌面上多出一个 git-demo-3 目录。我再说一遍，桌面上多出一个 git-demo-3 目录。我再说一遍，桌面上多出一个 git-demo-3 目录。这个细节很重要，很多人发现不了这个细节，我也不知道他们是眼瞎还是怎么了……</li><li>然后<code>cd git-demo-3</code>，对的，你肯定会忽略这一步。</li><li>然后<code>cd git-demo-3</code>，对的，你肯定会忽略这一步。</li><li>然后<code>cd git-demo-3</code>，对的，你肯定会忽略这一步。</li><li>好了你进入了这个目录了，如果没有，我就要吐血了，因为我的提示很明显。</li><li>运行 <code>ls -la</code> 你会看到，远程目录的所有文件都在这里出现了，另外你还看到了 .git 本地仓库。这时你就可以添加文件，git add，然后 git commit 了。</li></ol><p>三种方式都说完了，它们分别是：</p><blockquote><ol><li>在本地创建仓库</li><li>将本地仓库上传到 GitHub</li><li>下载 GitHub 上的仓库到本地</li></ol></blockquote><p>其实呢，我还可以说很多种不同的方式，但是，你记住这几种就行了，够你用的了。我们并不想要了解 git 的所有高级用法，我们的目的很明确：能通过 Git 命令使用 GitHub 就行。</p><p>我们再回顾一遍已经学到的命令：（这次只多了一个 git clone 命令）</p><ol><li><code>git clone git@github.com:xxxx</code>，下载仓库</li><li><code>git init</code>，初始化本地仓库 .git</li><li><code>git status -sb</code>，显示当前所有文件的状态</li><li><code>git add 文件路径</code>，用来将变动加到暂存区</li><li><code>git commit -m &quot;信息&quot;</code>，用来正式提交变动，提交至 .git 仓库</li><li>如果有新的变动，我们只需要依次执行 <code>git add xxx</code> 和 <code>git commit -m &#39;xxx&#39;</code>两个命令即可。别看本教程废话那么多，其实就这一句有用！先 add 再 commit，行了，你学会 git 了。</li><li><code>git log</code> 查看变更历史</li></ol><h2 id="如何上传更新"><a href="#如何上传更新" class="headerlink" title="如何上传更新"></a>如何上传更新</h2><p>你在本地目录有任何变动，只需按照以下顺序就能上传：</p><ol><li><code>git add 文件路径</code></li><li><code>git commit -m &quot;信息&quot;</code></li><li><code>git pull</code>（相信我，你一定会忘记这一个命令）</li><li><code>git push</code></li></ol><p>下面是例子</p><ol><li><code>cd git-demo-1</code></li><li><code>touch index2.html</code></li><li><code>git add index2.html</code></li><li><code>git commit -m &quot;新建 index2.html&quot;</code></li><li><code>git pull</code></li><li><code>git push</code><br>然后你去 git-demo-1 的 GitHub 页面，就能看到 index2.html 出现在里面了。是不是很……简……单……呢……</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有一些有用的命令</p><p><code>git remote add origin git@github.com:xxxxxxx.git</code> 将本地仓库与远程仓库关联<br><code>git remote set-url origin git@github.com:xxxxx.git</code> 上一步手抖了，可以用这个命令来挽回</p><ul><li><code>git branch</code>新建分支</li><li><code>git merge</code> 合并分支</li><li><code>git stash</code> 通灵术</li><li><code>git stash pop</code> 反转通灵术</li><li><code>git revert</code> 后悔了</li><li><code>git reset</code> 另一种后悔了</li><li><code>git diff</code> 查看详细变化<br>学 git 命令都够你们学一周的，所以别妄想现在就掌握它，切记。</li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html" target="_blank" rel="external">读懂diff-阮一峰</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="external">搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门</a></li><li><a href="http://www.runoob.com/git/git-install-setup.html" target="_blank" rel="external">Git 菜鸟教程</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743256916071d599b3aed534aaab22a0db6c4e07fd0000" target="_blank" rel="external">廖雪峰的 Git 教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置-GitHub&quot;&gt;&lt;a href=&quot;#配置-GitHub&quot; class=&quot;headerlink&quot; title=&quot;配置 GitHub&quot;&gt;&lt;/a&gt;配置 GitHub&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;进入 &lt;a href=&quot;https://github.com/setti
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="软件安装" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>笔记：导航页面</title>
    <link href="http://yoursite.com/2017/12/08/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%BC%E8%88%AA%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2017/12/08/笔记：导航页面/</id>
    <published>2017-12-08T08:33:08.000Z</published>
    <updated>2017-12-12T05:13:13.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天模仿一个<a href="http://www.36start.com/" target="_blank" rel="external">导航页面</a>  &gt;&gt;<a href="https://github.com/FrankFang/nav-demo" target="_blank" rel="external">代码</a></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul><li>选择数据结构</li><li>使用 JS 创建 HTML</li><li>添加 CSS</li><li>添加事件监听</li><li>打开网站</li></ul><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><code>&lt;kbd&gt;</code>标签：键盘标签</li><li><code>uncaught syntaxerror unexpected token</code> 语法错误</li><li><code>sublime</code>正则(替换),点击面板查找,再点最左上边的点加星号,开始替换<br> <img src="http://a1.qpic.cn/psb?/V149ONjw3gE9gi/KTghAkKc1mSrs.2y4fvTa84Xa7ei4XgzuiCDkzPvaiE!/b/dPMAAAAAAAAA&amp;bo=xgSqAAAAAAARAF8!&amp;rf=viewer_4" alt="img"></li><li><code>onclick</code> 用户点击事件<br><code>onkeypress</code> 键盘事件</li><li><code>oppend</code>==<code>echo &#39;hi&#39;&gt;&gt; 1.txt</code>中的<code>&gt;&gt;</code></li><li><strong>CSS:</strong> <code>text-tranform:uppercase</code> 指定如何将元素的文本大写，它可以用于使文本显示为全大写或全小写，也可单独对每一个单词进行操作。</li><li><code>local Storage</code> ：审查元素 &gt; Application &gt; storage &gt; local Storage</li><li>JS创建div：<code>document.createElement(&#39;div&#39;)</code></li><li>用JS插入文字：<code>textContent</code></li><li>JS如何向用户要一个网址：[例]<code>x=prompt(&#39;给我一个网址&#39;)</code></li><li>立体键盘：<code>box-shadow属性</code></li><li>开发者工具模拟2/3G网络加载图片效果：检查元素 &gt; network &gt; Online &gt; slow3G &gt; 禁用缓存(Disable cache勾上) &gt; 页面清空(Elements)</li><li>背景自适应：<code>background-size:cover;</code></li><li>获取各大网站logo：直接在地址栏尾加<code>/favicon.ico</code></li></ol><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><pre><code>1.声明一个二维数组(var keys...)2.声明一个hash(var hash...)3.如果发现之前存过一个hash，就把之前的hash覆盖掉(var hashInLocalStorage...)4.-遍历keys，生成多个kbd标签  -在每个kbd里面添加一个按钮，同时在按钮上做一个标记，标记它对应的id  -然后这个按钮被点击的时候，去包含所有事件信息的hash里面取target,因为target才是用户点击的元素，buttonX不是用户点击的元素，因为buttonX会变  -向用户要一个网址  -只要用户输入这个网址，我就去变更这个hash  -只要hash一改变，我就把hash存档到zzz里面5.在用户点击某一个按钮的时候，去打开hash里面对应的网址，同时要求新窗口打开</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天模仿一个&lt;a href=&quot;http://www.36start.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>如何购买域名</title>
    <link href="http://yoursite.com/2017/11/28/%E5%A6%82%E4%BD%95%E8%B4%AD%E4%B9%B0%E5%9F%9F%E5%90%8D/"/>
    <id>http://yoursite.com/2017/11/28/如何购买域名/</id>
    <published>2017-11-28T11:45:02.000Z</published>
    <updated>2017-11-28T12:56:56.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>购买域名有两个选择</p><ul><li>向国内服务商购买，不过你需要备案（备案就是把你的照片、姓名、住址 和手机号告诉管理机构）</li><li>向国外服务商购买，不需要备案，不过需要你懂一点英文</li></ul><p>我们当然毫不犹豫地选择后者。</p><h2 id="开始购买"><a href="#开始购买" class="headerlink" title="开始购买"></a>开始购买</h2><ol><li><p>进入<strong><a href="namesilo.com">域名购买</a></strong>搜索一个你喜欢的域名，比如我搜索的是phoebe-choi，然后你就会知道哪些域名是可以买的<br><img src="http://a1.qpic.cn/psb?/V149ONjw3gE9gi/anZo7oXvCvo2m71GLjtbvRZIS*OrWwMfF5AroRSBco0!/b/dPMAAAAAAAAA&amp;bo=vANbAQAAAAARANI!&amp;rf=viewer_4" alt="img"></p></li><li><p>其中最低的价格是<code>.xyz</code>域名，价格只要 1.89 美元，折合人民币 12 块五毛（每年），是不是很便宜。不要急，还有更便宜的，后面会教你搜索优惠码。现在我们先确定域名，如果你对<code>.xyz</code>不满意，可以选<code>phoebe-choi.info</code>，<code>.info</code> 域名比<code>.xyz</code> 稍微好看一点，当然你也可以选择<code>phoene-choi.me</code>、<code>phoebe-choi.pro</code>等。</p></li><li><p>选中你想要的域名，点击 REGISTER CHECKED DOMAINS 绿色按钮。<br><img src="http://a3.qpic.cn/psb?/V149ONjw3gE9gi/jpZ3Nww6ZYBp90RaFfJnmZTvqPvPkEerOKoEWavNZWw!/b/dPIAAAAAAAAA&amp;bo=kwNHAQAAAAARAOE!&amp;rf=viewer_4" alt="img1"></p></li><li><p>然后按照图中箭头设置隐私和期限<br><img src="http://a1.qpic.cn/psb?/V149ONjw3gE9gi/f5N2CNdFX3UsBZ7LFjYPFYyCpCaSm1ra1L62uUtHNLU!/b/dPMAAAAAAAAA&amp;bo=fQJdAQAAAAARABQ!&amp;rf=viewer_4" alt="img2"></p></li><li><p>别急着结账，有一个地方可以输入优惠码（如图）<br><img src="http://a3.qpic.cn/psb?/V149ONjw3gE9gi/FA2JbS8rT37DQ4Z16VL5VkmyBH1.XEUyLextg62r5VU!/b/dPIAAAAAAAAA&amp;bo=kAI8AQAAAAARAJg!&amp;rf=viewer_4" alt="img3"><br>去谷歌或者百度搜索<strong>「namesilo 优惠码」</strong>，填到里面，就可以优惠一美元！我搜到的优惠码是 onesaving。但是你要注意，一个用户只能使用一次优惠码，下次你再购买域名就没有优惠啦。</p></li><li><p>新用户注册完后，用支付宝结账（一定要先输入邮箱，再选中支付宝，最后点击 go）<br><img src="http://a3.qpic.cn/psb?/V149ONjw3gE9gi/kgNPdhJbEjBS*pwhgLhjAFmXtqu02Iins2J8gDnIc6s!/b/dPIAAAAAAAAA&amp;bo=mALtAQAAAAARAEE!&amp;rf=viewer_4" alt="img5"></p></li><li><p>购买成功！支付成功后域名就是你的了!</p></li><li><p>最后点击<code>Manage my domains</code>查看已经购买的域名。<br><img src="http://a1.qpic.cn/psb?/V149ONjw3gE9gi/nI9psNprmK7jUptcd6zD3oyBhq*emVILtNG8TB3sFSU!/b/dPMAAAAAAAAA&amp;bo=FwSnAAAAAAARAIM!&amp;rf=viewer_4" alt="img6"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;购买域名有两个选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向国内服务商购买，不过你需要备案（备案就是把你的照片、姓名、住址 和手机号告诉管理机构）&lt;/l
      
    
    </summary>
    
      <category term="域名" scheme="http://yoursite.com/categories/%E5%9F%9F%E5%90%8D/"/>
    
    
      <category term="域名" scheme="http://yoursite.com/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>预览Github上的页面</title>
    <link href="http://yoursite.com/2017/11/26/%E9%A2%84%E8%A7%88Github%E4%B8%8A%E7%9A%84%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2017/11/26/预览Github上的页面/</id>
    <published>2017-11-26T03:18:32.000Z</published>
    <updated>2017-11-29T07:35:12.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多新手把自己的网页上传到github仓库中却发现点进去相应的html文件显示出来的是下面代码，而不是自己想在网上看到自己仓库中的demo(也就是网页的效果) </p><p><img src="http://a1.qpic.cn/psb?/V149ONjw3gE9gi/mzPvN6ToHGEKEzW7Lo1cJc94BtleaiIilue4rA45B6Q!/b/dD4BAAAAAAAA&amp;bo=CQQuAgAAAAADBwM!&amp;rf=viewer_4" alt="img"></p><p>那么我们有没有办法预览项目中的html网页呢？好在github已经推出了 GitHub Pages 功能，让大家方便的预览自己的 HTML。下面就给大家做一个简易教程。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><strong>1. 登入 GitHub，新建一个 repo，设置如下：</strong></p><p><img src="http://a1.qpic.cn/psb?/V149ONjw3gE9gi/SbT1RAeZGsPCG1YHVWxHaqbJZb6iSyXu1aF0abmVxrE!/b/dPMAAAAAAAAA&amp;bo=rgLXAQAAAAADAF8!&amp;rf=viewer_4" alt="img1"></p><p><img src="http://a3.qpic.cn/psb?/V149ONjw3gE9gi/iE72VmBjtSCkLPbsuxfFGBns4zEVnpbULxnVOjgnTZQ!/b/dPIAAAAAAAAA&amp;bo=EgNsAgAAAAADAFo!&amp;rf=viewer_4" alt="img2"></p><p><strong>2. 进入「settings」页面：</strong></p><p><img src="http://a3.qpic.cn/psb?/V149ONjw3gE9gi/.YA.m6LqpFDfNqxbYG6I8SKkaGIq8FXvDYpL45*5t6E!/b/dGoBAAAAAAAA&amp;bo=uQNpAAAAAAADAPY!&amp;rf=viewer_4" alt="img3"></p><p><strong>3. 往下滚，按照图片中1-2-3的顺序，开启 GitHub Pages 功能，得到一个「预览地址」，我的「预览地址」是 <code>https://phoebe-choi.github.io/demo/.</code></strong></p><p><img src="http://a1.qpic.cn/psb?/V149ONjw3gE9gi/iVQXXnVQEnODR1AIQD8JHM4QSh8kGRrTkjtWo0*1oxk!/b/dPMAAAAAAAAA&amp;bo=0AJpAQAAAAADAJ8!&amp;rf=viewer_4" alt="img5"></p><p><strong>4. 以后你就用这个「预览地址」来预览你的 html，比如你的 html 路径是 test/index.html，那么预览链接就是 <code>https://phoebe-choi.github.io/demo/test/index.html</code> 步骤如下:</strong></p><p><img src="http://a3.qpic.cn/psb?/V149ONjw3gE9gi/rRqj8jMKvhhsbjssi9zh9UiudPmTCDGv3qXodn4ei20!/b/dFsBAAAAAAAA&amp;bo=0AOmAQAAAAADAFE!&amp;rf=viewer_4" alt="img6"></p><ul><li>新建 test/index.html</li></ul><p><img src="http://a1.qpic.cn/psb?/V149ONjw3gE9gi/KxFqGmwEyONrHng5kS986J8QtrjFiHVpyxBRibZgcNc!/b/dPMAAAAAAAAA&amp;bo=HQILAgAAAAADADM!&amp;rf=viewer_4" alt="img7"></p><ul><li><p>编辑好后点击下方的create new file即可创建文件，根据刚才创建的文件名称的相对路径就可以用「预览地址」来预览html文件了</p></li><li><p>在浏览器输入: <code>https://phoebe-choi.github.io/demo/test/index.html</code>进行预览</p></li></ul><p>这样，你就能自己随时预览 GitHub 里的页面了！</p><p>以后，<strong>你只需要用 git 上传代码到这个仓库</strong>，就可以拿到作业的预览链接了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;很多新手把自己的网页上传到github仓库中却发现点进去相应的html文件显示出来的是下面代码，而不是自己想在网上看到自己仓库中的demo(
      
    
    </summary>
    
      <category term="Github" scheme="http://yoursite.com/categories/Github/"/>
    
    
      <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>内联、块级元素的高度和文档流</title>
    <link href="http://yoursite.com/2017/11/25/%E5%86%85%E8%81%94%E3%80%81%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E7%9A%84%E9%AB%98%E5%BA%A6%E5%92%8C%E6%96%87%E6%A1%A3%E6%B5%81/"/>
    <id>http://yoursite.com/2017/11/25/内联、块级元素的高度和文档流/</id>
    <published>2017-11-25T11:53:07.000Z</published>
    <updated>2017-11-25T12:18:55.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内联元素的文档流"><a href="#内联元素的文档流" class="headerlink" title="内联元素的文档流"></a>内联元素的文档流</h2><p>先写十个<code>span</code>，并给这十个<code>span</code>加上样式，现在可以看到这十个<code>span</code>的方向是依次从左往右排开的。然后把网页拉到最外边界宽度最宽时，可以看到右边<code>文字10</code>已经断成两截了，并且自动换行继续从左往右散开。说明内联元素流动方向是从左往右流动的。</p><p><img src="http://a3.qpic.cn/psb?/V149ONjw3gE9gi/1Mnlbjd1pEjJQlcFYAz1QwaAFutH9VyPksLpQdRbBdI!/b/dPIAAAAAAAAA&amp;bo=yASSAQAAAAADB30!&amp;rf=viewer_4" alt="img1"></p><h2 id="块级元素的文档流"><a href="#块级元素的文档流" class="headerlink" title="块级元素的文档流"></a>块级元素的文档流</h2><p>我们再写十个<code>div</code>，也给这十个<code>div</code>加上边框，下图可以看到，如果是块级元素，就不从左往右流动了；而是每一个块都占一行。若是再增加一个新的div进来，就会另起一行继续从上往下流动。说明块级元素的流动方向是从上往下依次流动的。</p><p><img src="http://a1.qpic.cn/psb?/V149ONjw3gE9gi/i1zwytXTyKLVI9f1RKmF*WxUOKiHpJ1TzTgF*wI8LQI!/b/dPMAAAAAAAAA&amp;bo=zAQNAgAAAAADAOI!&amp;rf=viewer_4" alt="img2"></p><h2 id="内联元素：英文和中文的流动"><a href="#内联元素：英文和中文的流动" class="headerlink" title="内联元素：英文和中文的流动"></a>内联元素：英文和中文的流动</h2><p>现在把<code>span</code>里的内容换成一个长的英文串，再把网页拉到极限最宽。如下图，这说明了当一个内联元素里的内容为中文时，到达宽度极限的时候会自动换行；而当内联元素为英文，到达宽度极限时并不会换行，而是直接缩进了。</p><p><img src="http://a1.qpic.cn/psb?/V149ONjw3gE9gi/EAAAhC4qIkruSyIKbTsQPtRcyRFJX86gSU*neSA4IdU!/b/dPMAAAAAAAAA&amp;bo=zAQQAgAAAAADB*g!&amp;rf=viewer_4" alt="img3"></p><p>如果内联元素是一个很长的英文串，在默认情况下是不会分开的，若要解决这类问题，可以给这个元素加上一个属性：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">word-break</span><span class="selector-pseudo">:break-all</span>;<span class="comment">/*把单词分断*/</span></span><br></pre></td></tr></table></figure></p><h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p>若要让两个块级元素不上下分行，使之并排在同一行里，或像内联元素一样依次连起来，可以用两种办法<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>：<span class="selector-tag">inline-block</span>; 或 </span><br><span class="line"><span class="selector-tag">float</span><span class="selector-pseudo">:left</span>；</span><br></pre></td></tr></table></figure></p><p><img src="http://a3.qpic.cn/psb?/V149ONjw3gE9gi/0dRLvGDfD*I.hHRNMeyjdorUiwaUZuX1SdFuVUl6vTc!/b/dPIAAAAAAAAA&amp;bo=ygQ3AgAAAAADAN4!&amp;rf=viewer_4" alt="img4"></p><h2 id="块级元素和内联元素的高度"><a href="#块级元素和内联元素的高度" class="headerlink" title="块级元素和内联元素的高度"></a>块级元素和内联元素的高度</h2><ul><li><p>块级元素<br>块级元素的高度比较好理解，是由它内部文档流元素的总和决定的。</p></li><li><p>那么，内联元素的高度是由什么决定的呢？<br>我们先给<code>span</code>一个<code>font-size为100px</code>，现在看看图片左边，能看出来现在这个<code>hug</code>的像素是多高吗？</p></li></ul><p><img src="http://a1.qpic.cn/psb?/V149ONjw3gE9gi/BuJcHr.d524nFwE.xuuj*63c8Dg7CLFGUJdMWQqW48k!/b/dPMAAAAAAAAA&amp;bo=zARJAgAAAAADAKY!&amp;rf=viewer_4" alt="img5"></p><p>现在用尺子量一下，就可以看到这个<code>hug</code>的高度是97.5。并不足100。</p><p><img src="http://a3.qpic.cn/psb?/V149ONjw3gE9gi/DRQaoV96aC9Y4eclJUCc.xUcVZ06E*ZXyAl54*RCRZs!/b/dPIAAAAAAAAA&amp;bo=zAT5AQAAAAADABU!&amp;rf=viewer_4" alt="img6"></p><p>我们再加两个中文字<code>你好</code>来看看</p><p><img src="http://a3.qpic.cn/psb?/V149ONjw3gE9gi/dnIpcMPYRmqiXMXQDgr318OzNoTp3KpeQRzoQWlNjnY!/b/dPIAAAAAAAAA&amp;bo=zQTsAQAAAAADAAE!&amp;rf=viewer_4" alt="img7"></p><p>这个现象是不是很奇怪？我们现在加进去的<code>你好</code>量出来的高度才92.5，而刚刚<code>hug</code>量出来的高度是97.5，而我们给<code>span</code>的<code>font-size是100px</code>。再来看看下图</p><p><img src="http://a3.qpic.cn/psb?/V149ONjw3gE9gi/T.rXYKMOOnjAporyDmFSLboGEPnSjl6vS8Lalf7ZmyQ!/b/dPIAAAAAAAAA&amp;bo=xQR7AQAAAAADAJ4!&amp;rf=viewer_4" alt="img8"></p><p>测量出来上下红线的高度是140px。不管是<code>你好</code>的高度还是<code>hug</code>的高度，都不是我们<code>font-size</code>的100px，这是为什么呢？其实内联元素的高度是没有确定性的，即使你给一个内联元素设定了一个高度的数值，但浏览器还是会默认读取这个字体的行高，并且给你添加一点建议高度 。所以<code>font-size</code>的高度指的是内联元素里字体最高点和最低点的高度。</p><blockquote><p>内联元素的高度并不是我们设置的高度来决定的，而是由元素内部字体的最高低点决定的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内联元素的文档流&quot;&gt;&lt;a href=&quot;#内联元素的文档流&quot; class=&quot;headerlink&quot; title=&quot;内联元素的文档流&quot;&gt;&lt;/a&gt;内联元素的文档流&lt;/h2&gt;&lt;p&gt;先写十个&lt;code&gt;span&lt;/code&gt;，并给这十个&lt;code&gt;span&lt;/code&gt;加上
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>备份博客源文件</title>
    <link href="http://yoursite.com/2017/11/21/%E5%A4%87%E4%BB%BD%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/11/21/备份博客源文件/</id>
    <published>2017-11-21T13:44:14.000Z</published>
    <updated>2017-11-25T09:07:15.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用hexo+github搭建的博客,博客作为一个单独的github仓库存在,可是仓库中不包含你每篇博客的源文件。如果你换了一台机器想要更新博客或者不小心博客源文件丢失,那就真的是一件非常糟心的事，现在给出这个问题的一种解决办法吧。</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>首先在Github下创建一个新的repo，取名为blog-generator。(空仓库名随意，与本地的Hexo源码文件夹同名即可)</li><li>打开Git界面，cd进入本地的Hexo文件夹，执行以下命令创建仓库:<blockquote><p>git init</p></blockquote></li><li>继续执行下面命令设置远程仓库地址，并更新:<blockquote><p>git remote add origin git@github.com:xxxxxx/blog-generator.git (这里的xxxxxxx是你的用户名，记得用<strong>SSH地址</strong>)<br>git pull origin master</p></blockquote></li><li>执行命令以下命令，完成Hexo源码在本地的提交<blockquote><p>git add .<br>git commit -m “添加hexo源码文件作为备份”</p></blockquote></li><li>执行以下命令，将本地的仓库文件推送到Github。<blockquote><p>git push origin master</p></blockquote></li><li><strong>git clone git@github.com:xxxxxx/blog-generator.git</strong>这个是你GitHub的<strong>SSH</strong>地址，千万别用错成HTTP的地址！</li></ul><h3 id="博客更新后同步到远程仓库"><a href="#博客更新后同步到远程仓库" class="headerlink" title="博客更新后同步到远程仓库"></a>博客更新后同步到远程仓库</h3><ul><li>在本地编写完博客时，顺次执行以下命令，即可完成Hexo博客源文件的更新同步，保持Github上的hexo源码为最新版本。<blockquote><p>git add .<br>git commit -m “更新hexo源文件”<br>git push origin master</p></blockquote></li></ul><h3 id="远程仓库更新后同步到本地仓库"><a href="#远程仓库更新后同步到本地仓库" class="headerlink" title="远程仓库更新后同步到本地仓库"></a>远程仓库更新后同步到本地仓库</h3><ul><li>当远程仓库有更新时，执行以下命令，即可同步hexo源文件到本地。<blockquote><p>git pull origin master</p></blockquote></li><li>至此，Hexo源代码文件就同步和更新完了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;使用hexo+github搭建的博客,博客作为一个单独的github仓库存在,可是仓库中不包含你每篇博客的源文件。如果你换了一台机器想要更新
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【HTML标签介绍】</title>
    <link href="http://yoursite.com/2017/11/17/%E3%80%90HTML%E6%A0%87%E7%AD%BE%E4%BB%8B%E7%BB%8D%E3%80%91/"/>
    <id>http://yoursite.com/2017/11/17/【HTML标签介绍】/</id>
    <published>2017-11-17T09:49:50.000Z</published>
    <updated>2017-11-21T13:45:24.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Web浏览器中的网页的内容最根本的是文字，但网页中的内容在大多数时间都是风格文本而非纯文本。一个典型的网页基于集中技术（如CSS，JavaScript, Flash, AJAX, JSON）来控制终端用户的所见，但最根本的技术的是开发者用HTML来写网页，若没有HTML则没有网页。浏览器通过阅读HTML内容开始将网页展示在客户端设备上。</p><p>HTML的内容实在是太多了，今天写下这篇文章，先把所有的HTMLelements(元素)列出来。元素按功能分类，以方便日后更轻松地寻找元素。</p><h3 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h3><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;html&gt;</code></td><td>HTML <code>&lt;html&gt;</code> 元素 表示一个HTML文档的根（顶级元素），所所以它也被称为根元素。其他所有其他元素必须是此元素的后代。</td></tr></tbody></table><h3 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h3><p>元数据（Metadata）含有页面的相关信息，包括样式、脚本及数据，能帮助一些软件 (如搜索引擎， 浏览器等等）更好地运用和渲染页面。对于样式和脚本的元数据，可以直接在网页里定义，也可以链接到包含相关信息的外部文件。</p><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;base&gt;</code></td><td>HTML <code>&lt;base&gt;</code> 元素 指定用于一个文档中包含的所有相关URL的基本URL。一份中只能有一个<code>&lt;base&gt;</code>元素.</td></tr><tr><td style="text-align:left"><code>&lt;head&gt;</code></td><td>HTML head 元素 规定文档相关的通用信息（元数据），包括文档的标题，文档的样式和脚本的链接（定义）等。</td></tr><tr><td style="text-align:left"><code>&lt;link&gt;</code></td><td>HTML 中<code>&lt;link&gt;</code>元素指定了外部资源与当前文档的关系. 这个元素的使用方法包括为导航定义关系框架.这个元素经常用来链接css文件。</td></tr><tr><td style="text-align:left"><code>&lt;meta&gt;</code></td><td>HTML <code>&lt;meta&gt;</code> 元素表示那些不能由其它HTML元相关元素 (<code>&lt;base&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code> 或 <code>&lt;title&gt;</code>) 之一表示的任何元数据信息.</td></tr><tr><td style="text-align:left"><code>&lt;style&gt;</code></td><td>HTML的<code>&lt;style&gt;</code>元素包含了文档的样式化信息或者文档的一部分。指定的样式化星系包含的该元素内，通常是CSS的格式。</td></tr><tr><td style="text-align:left"><code>&lt;title&gt;</code></td><td>HTML <code>&lt;title&gt;</code> 元素 定义文档的标题，显示在浏览器的标题栏或标签页上。它只可以包含文本，若是包含有标签，则包含的任何标签都不会被解释。</td></tr></tbody></table><h3 id="内容分区"><a href="#内容分区" class="headerlink" title="内容分区"></a>内容分区</h3><p>内容分区元素允许你将文档内容从逻辑上进行组织划分。使用包括页眉(header)、页脚(footer)、导航(nav)和标题(h1~h6)等分区元素，来为页面内容创建明确的大纲，以便区分各个章节的内容。</p><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;address&gt;</code></td><td>HTML 的<code>&lt;address&gt;</code>元素可以让作者为它最近的<code>&lt;article&gt;</code>或者<code>&lt;body&gt;</code>祖先元素提供联系信息。在后一种情况下，它应用于整个文档。</td></tr><tr><td style="text-align:left"><code>&lt;article&gt;</code></td><td><code>&lt;article&gt;</code>元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。</td></tr><tr><td style="text-align:left"><code>&lt;aside&gt;</code></td><td><code>&lt;aside&gt;</code> 元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者嵌入内容。他们通常包含在工具条，例如来自词汇表的定义。也可能有其他类型的信息，例如相关的广告、笔者的传记、web 应用程序、个人资料信息，或在博客上的相关链接。</td></tr><tr><td style="text-align:left"><code>&lt;footer&gt;</code></td><td>HTML <code>&lt;footer&gt;</code> 元素表示最近一个章节内容或者根节点（sectioning root ）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。</td></tr><tr><td style="text-align:left"><code>&lt;h1–h6&gt;</code></td><td></td></tr><tr><td style="text-align:left"><code>&lt;header&gt;</code></td><td><code>&lt;header&gt;</code>元素表示一组引导性的帮助，可能包含标题元素，也可以包含其他元素，像logo、分节头部、搜索表单等。</td></tr><tr><td style="text-align:left"><code>&lt;hgroup&gt;</code></td><td>HTML <code>&lt;hgroup&gt;</code> Element (HTML Headings Group Element) 代表一个段的标题。它规定了在文档轮廓里（the outline of the document ）的单一标题是它所属的隐式或显式部分的标题。</td></tr><tr><td style="text-align:left"><code>&lt;nav&gt;</code></td><td>HTML导航栏 (<code>&lt;nav&gt;</code>) 描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表.</td></tr><tr><td style="text-align:left"><code>&lt;section&gt;</code></td><td>HTML Section 元素 (<code>&lt;section&gt;</code>) 表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading）。一般通过是否包含一个标题 (<code>&lt;h1&gt;-&lt;h6&gt;</code> element) 作为子节点 来 辨识每一个<code>&lt;section&gt;</code>。</td></tr></tbody></table><h3 id="文本内容"><a href="#文本内容" class="headerlink" title="文本内容"></a>文本内容</h3><p>使用 HTML 文本内容元素来组织在开标签 <code>&lt;body&gt;</code> 和闭标签 <code>&lt;/body&gt;</code> 里的块或章节的内容。这些元素能标识内容的宗旨或结构，而这对于 accessibility 和 SEO 很重要。</p><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;blockquote&gt;</code></td><td>HTML中的元素（或者 HTML 块级引用元素），代表其中的文字是引用内容。通常在渲染时，这部分的内容会有一定的缩进（注 中说明了如何更改）。若引文来源于网络，则可以将原内容的出处 URL 地址设置到 cite 特性上，若要以文本的形式告知读者引文的出处时，可以通过 <code>&lt;cite&gt;</code> 元素。</td></tr><tr><td style="text-align:left"><code>&lt;dd&gt;</code></td><td>HTML <code>&lt;dd&gt;</code> 元素（HTML 描述元素）用来指明一个描述列表  (<code>&lt;dl&gt;</code>) 元素中一个术语的描述。这个元素只能作为描述列表元素的子元素出现，并且必须跟着一个 <code>&lt;dt&gt;</code> 元素。</td></tr><tr><td style="text-align:left"><code>&lt;div&gt;</code></td><td>HTML <code>&lt;div&gt;</code> 元素 (或 HTML 文档分区元素) 是一个通用型的流内容容器，它在语义上不代表任何特定类型的内容，它可以被用来对其它元素进行分组，一般用于样式化相关的需求（使用 class 或 id 特性) 或者对具有相同特性的一组元素进行分组 (比如 lang)，它应该在没有任何其它语义元素可用是才使用 (比如 <code>&lt;article&gt; 或 &lt;nav&gt;</code>) 。</td></tr><tr><td style="text-align:left"><code>&lt;dl&gt;</code></td><td>HTML <code>&lt;dl&gt;</code> 元素 （或 HTML 描述列表元素）是一个包含术语定义以及描述的列表，通常用于展示词汇表或者元数据 (键-值对列表)。</td></tr><tr><td style="text-align:left"><code>&lt;dt&gt;</code></td><td>HTML <code>&lt;dt&gt;</code> 元素 （或 HTML 术语定义元素）用于在一个定义列表中声明一个术语。该元素仅能作为 <code>&lt;dl&gt;</code> 的子元素出现。通常在该元素后面会跟着 <code>&lt;dd&gt;</code> 元素， 然而，多个连续出现的 <code>&lt;dt&gt;</code> 元素都将由出现在它们后面的第一个 <code>&lt;dd&gt;</code>元素定义。</td></tr><tr><td style="text-align:left"><code>&lt;figcaption&gt;</code></td><td>HTML <code>&lt;figcaption&gt;</code> 元素 是与其相关联的图片的说明/标题，用于描述其父节点 <code>&lt;figure&gt;</code> 元素里的其他数据。这意味着 <code>&lt;figcaption&gt;</code> 在<code>&lt;figure&gt;</code> 块里是第一个或最后一个。同时 HTML Figcaption 元素是可选的；如果没有该元素，这个父节点的图片只是会没有说明/标题。</td></tr><tr><td style="text-align:left"><code>&lt;figure&gt;</code></td><td>HTML <code>&lt;figure&gt;</code> 元素代表一段独立的内容, 经常与说明(caption) <code>&lt;figcaption&gt;</code> 配合使用, 并且作为一个独立的引用单元。当它属于主体(main flow)时，它的位置独立于主体。这个标签经常是在主文中引用的图片，插图，表格，代码段等等，当这部分转移到附录中或者其他页面时不会影响到主体。</td></tr><tr><td style="text-align:left"><code>&lt;hr&gt;</code></td><td>HTML <code>&lt;hr&gt;</code> 元素表示段落级元素之间的主题转换（例如，一个故事中的场景的改变，或一个章节的主题的改变）。在HTML的早期版本中，它是一个水平线。现在它仍能在可视化浏览器中表现为水平线，但目前被定义为语义上的，而不是表现层面上。</td></tr><tr><td style="text-align:left"><code>&lt;li&gt;</code></td><td>HTML <code>&lt;li&gt;</code> 元素 (或者 HTML 列表条目元素) 用于表示列表里的条目。它必须被包含在一个父元素里：一个有顺序的列表(<code>&lt;ol&gt;</code>)，一个无顺序的列表(<code>&lt;ul&gt;</code>)，或者一个菜单 (<code>&lt;menu&gt;</code>)。在菜单或者无顺序的列表里，列表条目通常用点排列显示。在有顺序的列表里，列表条目通常是在左边有按升序排列计数的显示，例如数字或者字母。</td></tr><tr><td style="text-align:left"><code>&lt;main&gt;</code></td><td>HTML Main元素(<code>`&lt;main&gt;</code>)呈现了文档<code>&lt;body&gt;</code>或应用的主体部分。主体部分由与文档直接相关，或者扩展于文档的中心主题、应用的主要功能部分的内容组成。这部分内容在文档中应当是独一无二的，不包含任何在一系列文档中重复的内容，比如侧边栏，导航栏链接，版权信息，网站logo，搜索框（除非搜索框作为文档的主要功能）。<code>&lt;/main&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;ol&gt;</code></td><td>HTML <code>&lt;ol&gt;</code> 元素 表示多个有序列表项，通常渲染为有带编号的列表。</td></tr><tr><td style="text-align:left"><code>&lt;p&gt;</code></td><td>HTML <code>&lt;p&gt;</code>元素（或者说 HTML 段落元素）表示文本的一个段落。该元素通常表现为一整块与相邻文本分离的文本，或以垂直的空白隔离或以首行缩进。另外，<p> 是块级元素。</p></td></tr><tr><td style="text-align:left"><code>&lt;pre&gt;</code></td><td>HTML <code>&lt;pre&gt;</code> 元素表示预定义格式文本。在该元素中的文本通常按照原文件中的编排，以等宽字体的形式展现出来，文本中的空白符（比如空格和换行符）都会显示出来。(紧跟在 <code>&lt;pre&gt;</code>开始标签后的换行符也会被省略)</td></tr><tr><td style="text-align:left"><code>&lt;ul&gt;</code></td><td>The HTML<code>&lt;ul&gt;</code> 元素 ( 或 HTML 无序列表元素） 代表多项的无序列表，即无数值排序项的集合，且它们在列表中的顺序是没有意义的。通常情况下，无序列表项的头部可以是几种形式，如一个点，一个圆形或方形。头部的风格并不是在页面的HTML描述定义, 但在其相关的CSS 可以用 list-style-type 属性。</td></tr></tbody></table><h3 id="内联文本语义"><a href="#内联文本语义" class="headerlink" title="内联文本语义"></a>内联文本语义</h3><p>使用 HTML 内联文本语义(Inline text semantics)定义语句，结构，可以是一个词，一段，或任意风格的文字。</p><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;a&gt;</code>HTML</td><td><code>&lt;a&gt;</code>元素  (或锚元素) 创建一个到其他网页，文件，同一页面内的位置，电子邮件地址或任何其他URL的超链接。</td></tr><tr><td style="text-align:left"><code>&lt;abbr&gt;</code></td><td>HTML <code>&lt;abbr&gt;</code>元素代表缩写，并可选择提供一个完整的描述。</td></tr><tr><td style="text-align:left"><code>&lt;b&gt;</code>HTML</td><td><code>&lt;b&gt;</code> 元素表示相对于普通文本字体上的区别，但不表示任何特殊的强调或者关联。它通常用在摘要中的关键字、审查中的产品名称或者其他需要显示为加粗的文字区域。它的另一个使用例子是用来标记一篇文章中每一段的引言。</td></tr><tr><td style="text-align:left"><code>&lt;bdi&gt;</code></td><td>HTML <code>&lt;bdi&gt;</code> 元素 (双向隔离元素) 会隔离可能以不同方向进行格式化的外部文本。</td></tr><tr><td style="text-align:left"><code>&lt;bdo&gt;</code></td><td><code>&lt;bdo&gt;</code> 元素 (HTML双向覆盖元素)用于覆盖当前文本的朝向，它使得字符的排列方式被给定的方向覆盖。</td></tr><tr><td style="text-align:left"><code>&lt;br&gt;</code></td><td>HTML 元素 换行 <code>&lt;br&gt;</code> 在文本中产生一个换行（回车键）。这对于写诗或写一个地址来说显得很有用。它可以将行明显地分开。</td></tr><tr><td style="text-align:left"><code>&lt;cite&gt;</code></td><td>HTML引用（ Citation）标签 (<code>&lt;cite&gt;</code>) 表示一个作品的引用。它必须包含引用作品的符合简写格式的标题或者URL。It must include the title of a work or a URL reference, which may be in an abbreviated form according to the conventions used for the addition of citation metadata.</td></tr><tr><td style="text-align:left"><code>&lt;code&gt;</code></td><td>HTML <code>&lt;code&gt;</code> 元素呈现一段计算机代码. 默认情况下, 它以浏览器的默认等宽字体显示.</td></tr><tr><td style="text-align:left"><code>&lt;data&gt;</code></td><td>HTML <code>&lt;data&gt;</code> 元素 将一个指定内容和机器可读的翻译联系在一起。但如果内容是与 time 或者 date 相关的，一定要使用 <code>&lt;time&gt;</code>。</td></tr><tr><td style="text-align:left"><code>&lt;dfn&gt;</code></td><td>HTML 定义元素 (<code>&lt;dfn&gt;</code>) 表示术语的一个定义。</td></tr><tr><td style="text-align:left"><code>&lt;em&gt;</code></td><td>HTML 着重元素 (<code>&lt;em&gt;</code>) 标记出需要用户着重阅读的内容， <code>&lt;em&gt;</code> 元素是可以嵌套的，嵌套层次越深，则其包含的内容被认定为越需要着重阅读。</td></tr><tr><td style="text-align:left"><code>&lt;i&gt;</code></td><td>HTML元素 <code>&lt;i&gt;</code> 用于表现因某些原因需要区分普通文本的一系列文本。例如技术术语、外文短语或是小说中人物的思想活动等，它的内容通常以斜体显示。</td></tr><tr><td style="text-align:left"><code>&lt;kbd&gt;</code></td><td>HTML键盘输入元素(<code>&lt;kbd&gt;</code>) 用于表示用户输入，它将产生一个行内元素，以浏览器的默认monospace字体显示。</td></tr><tr><td style="text-align:left"><code>&lt;mark&gt;</code></td><td>这个 HTML mark 标签代表突出显示的文字,例如可以为了标记特定上下文中的文本而使用这个标签. 举个例子，它可以用来显示搜索引擎搜索后关键词。</td></tr><tr><td style="text-align:left"><code>&lt;q&gt;</code></td><td>HTML引用标签 <code>(&lt;q&gt;)</code>表示一个封闭的并且是短的行内引用的文本. 这个标签是用来引用短的文本，所以请不要引入换行符; 对于长的文本的引用请使用 <code>&lt;blockquote&gt;</code> 替代.</td></tr><tr><td style="text-align:left"><code>&lt;rp&gt;</code></td><td>HTML <code>&lt;rp&gt;</code> 元素用于为那些不能使用 <code>&lt;ruby&gt;</code> 元素展示 ruby 注解的浏览器，提供随后的圆括号。</td></tr><tr><td style="text-align:left"><code>&lt;rt&gt;</code></td><td>HTML<code>&lt;rt&gt;</code> element 包含字符的发音，字符在 ruby 注解中出现，它用于描述东亚字符的发音。这个元素始终在 <code>&lt;ruby&gt;</code> 元素中使用。</td></tr><tr><td style="text-align:left"><code>&lt;rtc&gt;</code></td><td>HTML <code>&lt;rtc&gt;</code> 元素包含文字的语义注解，它们在 <code>&lt;rb&gt;</code> 元素中展示。<code>&lt;rb&gt;</code> 元素可以拥有发音 (<code>&lt;rt&gt;</code>) 和语义(<code>&lt;rtc&gt;</code>) 注解。</td></tr><tr><td style="text-align:left"><code>&lt;ruby&gt;</code></td><td>HTML <code>&lt;ruby&gt;</code> 元素 被用来展示东亚文字注音或字符注释。</td></tr><tr><td style="text-align:left"><code>&lt;s&gt;</code></td><td>HTML <code>&lt;s&gt;</code> 元素 使用删除线来渲染文本。使用 <code>&lt;s&gt;</code> 元素来表示不再相关，或者不再准确的事情。但是当表示文档编辑时，不提倡使用 <code>&lt;s&gt;</code> ；为此，提倡使用 <code>&lt;del&gt;</code> 和 <code>&lt;ins&gt;</code> 元素。</td></tr><tr><td style="text-align:left"><code>&lt;samp&gt;</code></td><td><code>&lt;samp&gt;</code> 元素用于标识计算机程序输出，通常使用浏览器缺省的 monotype 字体（例如 Lucida Console）。</td></tr><tr><td style="text-align:left"><code>&lt;small&gt;</code></td><td>HTML 中的元素將使文本的字体变小一号。(例如从大变成中等，从中等变成小，从小变成超小)。在HTML5中，除了它的样式含义，这个元素被重新定义为表示边注释和附属细则，包括版权和法律文本。</td></tr><tr><td style="text-align:left"><code>&lt;span&gt;</code></td><td>HTML <code>&lt;span&gt;</code> 元素是短语内容的通用行内容器，并没有任何特殊语义。可以使用它来编组元素以达到某种样式意图（通过使用类或者Id属性），或者这些元素有着共同的属性，比如lang。应该在没有其他合适的语义元素时才使用它。<code>&lt;span&gt;</code> 与 <code>&lt;div&gt;</code> 元素很相似，但 <code>&lt;div&gt;</code> 是一个 块元素 而 <code>&lt;span&gt;</code> 则是 行内元素 .</td></tr><tr><td style="text-align:left"><code>&lt;strong&gt;</code></td><td>Strong 元素 <code>(&lt;strong&gt;</code>)表示文本十分重要，一般用粗体显示。</td></tr><tr><td style="text-align:left"><code>&lt;sub&gt;</code></td><td>HTML <code>&lt;sub&gt;</code> 元素定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更低并且更小。</td></tr><tr><td style="text-align:left"><code>&lt;sup&gt;</code></td><td>HTML <code>&lt;sup&gt;</code> 元素定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更高并且更小。</td></tr><tr><td style="text-align:left"><code>&lt;time&gt;</code></td><td>HTML time 标签(<code>&lt;time&gt;</code>) 用来表示24小时制时间或者公历日期，若表示日期则也可包含时间和时区。</td></tr><tr><td style="text-align:left"><code>&lt;u&gt;</code></td><td>HTML <code>&lt;u&gt;</code> 元素使文本在其内容的基线下的一行呈现下划线。在HTML5中, 此元素表示具有未标注的文本跨度，显示渲染，非文本注释，例如将文本标记为中文文本中的专有名称(一个正确的中文标记), 或 将文本标记为拼写错误。</td></tr><tr><td style="text-align:left"><code>&lt;var&gt;</code></td><td><code>&lt;var&gt;</code> 标签表示变量的名称，或者由用户提供的值。</td></tr><tr><td style="text-align:left"><code>&lt;wbr&gt;</code></td><td>HTML <code>&lt;wbr&gt;</code> 元素  — 一个文本中的位置，其中浏览器可以选择来换行，虽然它的换行规则可能不会在这里换行。</td></tr></tbody></table><h3 id="图片和多媒体"><a href="#图片和多媒体" class="headerlink" title="图片和多媒体"></a>图片和多媒体</h3><p>HTML 支持各种多媒体资源，例如图像，音频和视频。</p><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;area&gt;</code></td><td>HTML <code>&lt;area&gt;</code> 元素 在图片上定义一个热点区域</td></tr><tr><td style="text-align:left"><code>&lt;audio&gt;</code></td><td>HTML <code>&lt;audio&gt;</code> 元素用于在文档中表示音频内容。<code>&lt;audio&gt;</code> 元素可以包含多个音频资源， 这些音频资源可以使用 src 属性或者<code>&lt;source&gt;</code>元素来进行描述； 浏览器将会选择最合适的一个来使用。对于不支持<code>&lt;audio&gt;</code>元素的浏览器，<code>&lt;audio&gt;</code>元素也可以作为浏览器不识别的内容加入到文档中。</td></tr><tr><td style="text-align:left"><code>&lt;img&gt;</code></td><td>HTML Image 元素（ <code>&lt;img&gt;</code> ）代表文档中的一个图像。</td></tr><tr><td style="text-align:left"><code>&lt;map&gt;</code></td><td>HTML <code>&lt;map&gt;</code> 属性 与 <code>&lt;area&gt;</code>属性一起使用来定义一个图像映射(一个可点击的链接区域).</td></tr><tr><td style="text-align:left"><code>&lt;track&gt;</code></td><td>HTML <code>&lt;track&gt;</code> 元素 被当作媒体元素—<code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code>的子元素来使用。它允许指定计时字幕（或者基于事件的数据），例如自动处理字幕。</td></tr><tr><td style="text-align:left"><code>&lt;video&gt;</code></td><td>HTML <code>&lt;video&gt;</code> 元素 用于在HTML或者XHTML文档中嵌入视频内容。</td></tr></tbody></table><h3 id="内嵌内容"><a href="#内嵌内容" class="headerlink" title="内嵌内容"></a>内嵌内容</h3><p>除了常规的多媒体内容，HTML 可以包括各种其他的内容，即使它并不容易交互。</p><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;embed&gt;</code></td><td>HTML <code>&lt;embed&gt;</code> 元素 用于表示一个外部应用或交互式内容的集合点，换句话说，就是一个插件。</td></tr><tr><td style="text-align:left"><code>&lt;object&gt;</code></td><td>HTML <code>&lt;object&gt;</code>元素（或者称作 HTML 嵌入对象元素）表示引入一个外部资源，这个资源可能是一张图片，一个嵌入的浏览上下文，亦或是一个插件所使用的资源。</td></tr><tr><td style="text-align:left"><code>&lt;param&gt;</code></td><td>HTML <code>&lt;param&gt;</code> 元素(或 HTML Parameter 元素) 定义了 <code>&lt;object&gt;</code>的参数</td></tr><tr><td style="text-align:left"><code>&lt;source&gt;</code></td><td>The HTML <code>&lt;source&gt;</code> element specifies multiple media resources for either the <code>&lt;picture&gt;</code>, the <code>&lt;audio&gt;</code> or the <code>&lt;video&gt;</code> element. It is an empty element. It is commonly used to serve the same media content in multiple formats supported by different browsers.</td></tr></tbody></table><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>为了创建动态内容和 Web 应用程序，HTML 支持使用脚本语言，最突出的就是 JavaScript。某些元素支持此功能。</p><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;canvas&gt;</code></td><td><code>&lt;canvas&gt;</code>元素可被用来通过脚本（通常是JavaScript）绘制图形。比如,它可以被用来绘制图形,制作图片集合,甚至用来实现动画效果。你可以(也应该)在元素标签内写入可提供替代的的代码内容，这些内容将会在在旧的、不支持<code>&lt;canvas&gt;</code>元素的浏览器或是禁用了JavaScript的浏览器内渲染并展现。</td></tr><tr><td style="text-align:left"><code>&lt;noscript&gt;</code></td><td>如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则HTML <code>&lt;noscript&gt;</code>元素定义要插入的html部分。<code>&lt;/noscript&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;script&gt;</code></td><td>HTML <code>&lt;script&gt;</code>元素用于嵌入或引用可执行脚本。</td></tr></tbody></table><h3 id="编辑标识"><a href="#编辑标识" class="headerlink" title="编辑标识"></a>编辑标识</h3><p>这些元素能标示出某个文本被更改过的部分。</p><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;del&gt;</code></td><td>HTML 删除文字元素（<code>&lt;del&gt;</code>）表示已经从文档中删除的文本范围。此元素通常是（但不必）呈现删除线的文本。</td></tr><tr><td style="text-align:left"><code>&lt;ins&gt;</code></td><td>HTML <code>&lt;ins&gt;</code> 元素定义已经被插入文档中的文本。</td></tr></tbody></table><h3 id="表格内容"><a href="#表格内容" class="headerlink" title="表格内容"></a>表格内容</h3><p>这里的元素用于创建和处理表格数据,元素在一个元素中可以出现一个或者更多。</p><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;caption&gt;</code></td><td>HTML <code>&lt;caption&gt;</code> 元素 (or HTML 表格标题元素) 展示一个表格的标题， 它常常作为 <code>&lt;table&gt;</code>的第一个子元素出现，同时显示在表格内容的最前面，但是，它同样可以被CSS样式化，所以，它同样可以出现在任何一个一个相对于表格的做任意位置。</td></tr><tr><td style="text-align:left"><code>&lt;col&gt;</code></td><td>HTML <code>&lt;col&gt;</code> 元素 定义表格中的列，并用于定义所有公共单元格上的公共语义。它通常位于<code>&lt;colgroup&gt;</code>元素内。</td></tr><tr><td style="text-align:left"><code>&lt;colgroup&gt;</code></td><td>HTML 中的 表格列组（Column Group <code>&lt;colgroup&gt;</code>） 标签用来定义表中的一组列表。</td></tr><tr><td style="text-align:left"><code>&lt;table&gt;</code></td><td>HTML的 table 元素表示表格数据 — 即通过二维数据表表示的信息。</td></tr><tr><td style="text-align:left"><code>&lt;tbody&gt;</code></td><td>这个 HTML 标签</td></tr><tr><td style="text-align:left"><code>&lt;td&gt;</code></td><td>The Table cell HTML element (<code>&lt;td&gt;</code>) defines a cell of a table that contains data. It participates in the table model.</td></tr><tr><td style="text-align:left"><code>&lt;tfoot&gt;</code></td><td></td></tr><tr><td style="text-align:left"><code>&lt;th&gt;</code></td><td></td></tr><tr><td style="text-align:left"><code>&lt;thead&gt;</code></td><td>HTML的<code>&lt;thead&gt;</code>元素定义了一组定义表格的列头的行。</td></tr><tr><td style="text-align:left"><code>&lt;tr&gt;</code></td><td>HTML <code>&lt;tr&gt;</code> 元素定义表格中的行。 Those can be a mix of <code>&lt;td&gt;</code> and <code>&lt;th&gt;</code> elements.</td></tr></tbody></table><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>HTML 提供了许多可一起使用的元素，这些元素能用来创建一个用户可以填写并提交到网站或应用程序的表单。详情请参阅 HTML forms guide。</p><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;button&gt;</code></td><td>HTML<code>&lt;button&gt;</code>元素 表示一个可点击的按钮。</td></tr><tr><td style="text-align:left"><code>&lt;datalist&gt;</code></td><td>HTML Datalist 元素 (<code>&lt;datalist&gt;</code>) 包含了一组<code>&lt;option&gt;</code>元素,这些元素表示其它表单控件可选值.</td></tr><tr><td style="text-align:left"><code>&lt;fieldset&gt;</code></td><td></td></tr><tr><td style="text-align:left"><code>&lt;form&gt;</code></td><td>HTML<code>&lt;form&gt;</code> 元素 表示了文档中的一个区域，这个区域包含有交互控制元件，用来向web服务器提交信息。</td></tr><tr><td style="text-align:left"><code>&lt;input&gt;</code></td><td>HTML<code>&lt;input&gt;</code> 元素用于为基于Web的表单创建交互式控件，以便接受来自用户的数据。</td></tr><tr><td style="text-align:left"><code>&lt;label&gt;</code></td><td>HTML 元素表示用户界面中项目的标题。</td></tr><tr><td style="text-align:left"><code>&lt;legend&gt;</code></td><td>HTML的<code>&lt;legend&gt;</code>元素（也称为HTML的域说明元素（or HMTLLegend Field Element））代表一个用于表示它的父元素<code>&lt;fieldset&gt;</code>的内容的标题<code>&lt;/legend&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;meter&gt;</code></td><td>HTML<code>&lt;meter&gt;</code>元素用来显示已知范围的标量值或者分数值。</td></tr><tr><td style="text-align:left"><code>&lt;optgroup&gt;</code></td><td>在一个web表单中, HTML元素 <code>&lt;optgroup&gt;</code> 会创建包含在一个 <code>&lt;select&gt;</code>元素中的一组选项</td></tr><tr><td style="text-align:left"><code>&lt;option&gt;</code></td><td>在web表单中,  HTML元素 <code>&lt;option&gt;</code>  用于定义在<code>&lt;select&gt;</code>, <code>&lt;optgroup&gt;</code> 或<code>&lt;datalist&gt;</code> 元素中包含的项.<code>&lt;option&gt;</code>可以在弹出窗口和 html 文档中的其他项目列表中表示菜单项。</td></tr><tr><td style="text-align:left"><code>&lt;output&gt;</code></td><td>HTML 标签定义一个用户的操作或者计算的结果。</td></tr><tr><td style="text-align:left"><code>&lt;progress&gt;</code></td><td>HTML中的progress (<code>&lt;progress&gt;</code>) 元素用来显示一项任务的完成进度.虽然规范中没有规定该元素具体如何显示,浏览器开发商可以自己决定,但通常情况下,该元素都显示为一个进度条形式.</td></tr><tr><td style="text-align:left"><code>&lt;select&gt;</code></td><td>HTML select (<code>&lt;select&gt;</code>) 元素是一种表单控件，可创建选项菜单。菜单内的选项为<code>&lt;option&gt;</code> , 可以由 <code>&lt;optgroup&gt;</code> 元素分组。选项可以被用户预先选择。</td></tr><tr><td style="text-align:left"><code>&lt;textarea&gt;</code></td><td>HTML <code>&lt;textarea&gt;</code> 元素表示一个多行纯文本编辑控件。</td></tr></tbody></table><h3 id="交互元素"><a href="#交互元素" class="headerlink" title="交互元素"></a>交互元素</h3><p>HTML 提供了一系列有助于创建交互式用户界面对象的元素。</p><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;details&gt;</code></td><td>HTML <code>&lt;details&gt;</code> 元素被用作发现小部件，用户可以从其中检索附加信息。</td></tr><tr><td style="text-align:left"><code>&lt;dialog&gt;</code></td><td>HTML <code>&lt;dialog&gt;</code> 元素表示一个对话框或其他交互式组件，例如一个检查员或窗口。</td></tr><tr><td style="text-align:left"><code>&lt;menu&gt;</code></td><td>HTML <code>&lt;menu&gt;</code> 元素 呈现了一组用户可执行或激活的命令。这既包含了可能出现在屏幕顶端的列表菜单，也包含了那些隐藏在按钮之下、当点击按钮后显示出来的文本菜单。</td></tr><tr><td style="text-align:left"><code>&lt;menuitem&gt;</code></td><td></td></tr><tr><td style="text-align:left"><code>&lt;summary&gt;</code></td><td>HTML <code>&lt;summary&gt;</code> 元素 用作 一个<code>&lt;details&gt;</code>元素的一个内容的摘要，标题或图例。</td></tr></tbody></table><h3 id="Web-组件"><a href="#Web-组件" class="headerlink" title="Web 组件"></a>Web 组件</h3><p>Web 组件是种近似 HTML（HTML-related） 的技术，这使得它能够，从本质上讲，创建和使用自定义元素，就好像它是普通的 HTML。此外，你甚至可以创建自定义版本的标准 HTML 元素。<br><strong>注意: Web组件的元素都在 World Wide Web Consortium (W3C) Web Components collection of specifications 定义而不是 HTML 规范。此外，Web 组件规范还没有最后确定，随时有可能发生更改。</strong></p><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;content&gt;</code></td><td>HTML <code>&lt;content&gt;</code> 元素— Web 组件 的技术套件的废弃部分 — 用于 Shadow DOM 内部作为 insertion point，并且不可用于任何正常的 HTML，现在已被 <code>&lt;slot&gt;</code> 元素代替，它在 DOM 中创建一个位置，Shadow DOM 会插入这里。</td></tr><tr><td style="text-align:left"><code>&lt;element&gt;</code></td><td><code>&lt;element&gt;</code>元素被定义在最新的 HTML DOM 元素中。<code>&lt;/element&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;shadow&gt;</code></td><td>HTML <code>&lt;shadow&gt;</code> 元素 — Web 组件技术套件的废弃部分 — 目的是用作 Shadow DOM insertion point。如果你在 shadow host 下面创建了多个 shadow root，你就可能已经使用了它。在正常的 HTML 没有任何用处。</td></tr><tr><td style="text-align:left"><code>&lt;slot&gt;</code></td><td>HTML <code>&lt;slot&gt;</code> 标签是web组件技术的一部分，slot是web组件的一个占位符，可以用来插入自定义的标记文本。可以创建不同的DOM树并进行渲染。</td></tr><tr><td style="text-align:left"><code>&lt;template&gt;</code></td><td>HTML <code>&lt;template&gt;</code> 元素 是一种用于保存客户端内容的机制，该内容在页面加载时不被渲染，但可以在运行时使用JavaScript进行实例化。</td></tr></tbody></table><h3 id="过时的和弃用的元素"><a href="#过时的和弃用的元素" class="headerlink" title="过时的和弃用的元素"></a>过时的和弃用的元素</h3><p><strong>警告: 下面这些旧的 HTML 元素已被弃用，不应该再使用。你千万别在新的项目中使用它们，并且要尽快替换在旧项目里的。在此列出仅供参考。</strong></p><table><thead><tr><th style="text-align:left">元素</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;acronym&gt;</code></td><td>HTML Acronym  元素 (<code>&lt;acronym&gt;</code>) 允许作者明确地声明一个字符序列,，它们构成一个单词的首字母缩写或简略语。</td></tr><tr><td style="text-align:left"><code>&lt;applet&gt;</code></td><td>HTML中的Applet元素(<code>&lt;applet&gt;</code>) 标志着包含了Java的applet。</td></tr><tr><td style="text-align:left"><code>&lt;basefont&gt;</code></td><td>HTML标签<code>&lt;basefont&gt;&lt;/basefont&gt;</code>用来设置文档的默认字体大小。使用<code>&lt;font&gt;</code>可以相对于默认字体大小进行变化。</td></tr><tr><td style="text-align:left"><code>&lt;big&gt;</code></td><td>The HTML Big Element (<code>&lt;big&gt;</code>) 会使字体加大一号（例如从小号(small)到中号(medium)，从大号(large)到加大(x-large)），最大不超过浏览器的最大字体。</td></tr><tr><td style="text-align:left"><code>&lt;blink&gt;</code></td><td>HTML Blink Element (<code>&lt;blink&gt;</code>)不是标准元素，它会使包含其中的文本闪烁。</td></tr><tr><td style="text-align:left"><code>&lt;center&gt;</code></td><td>HTML Center 元素 (<code>&lt;center&gt;</code>) 是个 块级元素，可以包含段落，以及其它块级和内联元素。这个元素的整个内容在它的上级元素中水平居中(通常是 <code>&lt;body&gt;</code>)。</td></tr><tr><td style="text-align:left"><code>&lt;command&gt;</code></td><td>command元素用来表示一个用户可以调用的命令.</td></tr><tr><td style="text-align:left"><code>&lt;content&gt;</code></td><td>HTML <code>&lt;content&gt;</code> 元素— Web 组件 的技术套件的废弃部分 — 用于 Shadow DOM 内部作为 insertion point，并且不可用于任何正常的 HTML，现在已被 <code>&lt;slot&gt;</code> 元素代替，它在 DOM 中创建一个位置，Shadow DOM 会插入这里。</td></tr><tr><td style="text-align:left"><code>&lt;dir&gt;</code></td><td>HTML 目录元素 (<code>&lt;dir&gt;</code>) 表示一个目录，也就是文件名称的集合。</td></tr><tr><td style="text-align:left"><code>&lt;element&gt;</code></td><td><code>&lt;element&gt;</code>元素被定义在最新的 HTML DOM 元素中。<code>&lt;/element&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;font&gt;</code></td><td>HTML Font 元素（<code>&lt;font&gt;</code>）定义了该内容的字体大小、顏色与表现。</td></tr><tr><td style="text-align:left"><code>&lt;frame&gt;</code></td><td><code>&lt;frame&gt;</code> 是 HTML 元素，它定义了一个特定区域，另一个 HTML 文档可以在里面展示。帧应该在 <code>&lt;frameset&gt;</code>中使用。</td></tr><tr><td style="text-align:left"><code>&lt;frameset&gt;</code></td><td><code>&lt;frameset&gt;</code> 是一个HTML元素，用于包含 <code>&lt;frame&gt;</code>元素。</td></tr><tr><td style="text-align:left"><code>&lt;image&gt;</code></td><td>HTML <code>&lt;image&gt;</code>元素曾经是一个试验性的元素，用来显示图片。它从未被实现过，请使用标准的<code>&lt;img&gt;</code>元素。</td></tr><tr><td style="text-align:left"><code>&lt;isindex&gt;</code></td><td><code>&lt;isindex&gt;</code>元素的作用是使浏览器显示一个对话框，提示用户输入单行文本。在W3C的规范中建议，<code>&lt;isindex&gt;</code>元素最好被放置在 <code>&lt;head&gt;</code>标签块内，但是对于浏览器来说，<code>&lt;isindex&gt;</code>标签在页面任何位置都没有关系。</td></tr><tr><td style="text-align:left"><code>&lt;keygen&gt;</code></td><td>HTML <code>&lt;keygen&gt;</code> 元素是为了方便生成密钥材料和提交作为 HTML form 的一部分的公钥.这种机制被用于设计基于 Web 的证书管理系统。按照预想，<code>&lt;keygen&gt;</code> 元素将用于 HTML 表单与其他的所需信息一起构造一个证书请求，该处理的结果将是一个带有签名的证书。</td></tr><tr><td style="text-align:left"><code>&lt;listing&gt;</code></td><td>HTML 列表元素 (<code>&lt;listing&gt;</code>) 渲染了开始和结束标签之间的文本，而不会解释 HTML，并使用等宽字体。HTML2 标准建议，当一行不超过 132 个字符时，不应该将其拆开。</td></tr><tr><td style="text-align:left"><code>&lt;marquee&gt;</code></td><td>HTML marquee 元素（<code>&lt;marquee&gt;</code>） 用来插入一段滚动的文字。你可以使用它的属性控制当文本到达容器边缘发生的事情。</td></tr><tr><td style="text-align:left"><code>&lt;multicol&gt;</code></td><td>HTML<code>&lt;multicol&gt;</code> 元素是一个实验元素，旨在允许多列布局。它从来没有任何显着的牵引力，并没有在任何主流浏览器中实现。<code>&lt;/multicol&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;nextid&gt;</code></td><td></td></tr><tr><td style="text-align:left"><code>&lt;noembed&gt;</code></td><td><code>&lt;noembed&gt;</code> 元素是个废除的和不标准的方式，用于向不支持 <code>&lt;embed&gt;</code> ，或者不支持作者希望的 嵌入式内容 的浏览器提供替代（或者“后备”）内容。这个元素在 HTML 4.01 起废除，以支持</td></tr><tr><td style="text-align:left"><code>&lt;plaintext&gt;</code></td><td>HTML 纯文本元素 (<code>&lt;plaintext&gt;</code>) 将起始标签后面的任何东西渲染为纯文本，不会解释为 HTML。它没有闭合标签，因为任何后面的东西都会看做纯文本。</td></tr><tr><td style="text-align:left"><code>&lt;shadow&gt;</code></td><td>HTML <code>&lt;shadow&gt;</code> 元素 — Web 组件技术套件的废弃部分 — 目的是用作 Shadow DOM insertion point。如果你在 shadow host 下面创建了多个 shadow root，你就可能已经使用了它。在正常的 HTML 没有任何用处。</td></tr><tr><td style="text-align:left"><code>&lt;spacer&gt;</code></td><td><code>&lt;spacer&gt;</code> 是过时的 HTML 元素，它可以向页面插入间隔。它由 Netscape 设计，用于实现单像素布局图像的相同效果，Web 设计师用它来向页面添加空白，而不需要实际使用图片。 但是，<code>&lt;spacer&gt;</code> 不再受任何主流浏览器支持，并且相同效果可以简单由 CSS 实现。</td></tr><tr><td style="text-align:left"><code>&lt;strike&gt;</code></td><td>HTML <code>&lt;strike&gt;</code>元素（或者 HTML 删除线元素）在文本上放置删除线。</td></tr><tr><td style="text-align:left"><code>&lt;tt&gt;</code></td><td>HTML 电报文本元素 (<code>&lt;tt&gt;</code>) 产生一个内联元素，使用浏览器内置的 monotype 字体展示。这个元素用于给文本排版，使其等宽展示，就像电报那样。使用 <code>&lt;code&gt;</code>元素来展示等宽文本可能更加普遍。</td></tr><tr><td style="text-align:left"><code>&lt;xmp&gt;</code></td><td><code>&lt;xmp&gt;</code>标签之间的内容不会被当作文档内容解析，而会被用等宽字体直接呈现。HTML2规范建议，本标签中的内容应该具有足够容纳每行80个字母的宽度。<code>&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/p&gt;&lt;/xmp&gt;</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Web浏览器中的网页的内容最根本的是文字，但网页中的内容在大多数时间都是风格文本而非纯文本。一个典型的网页基于集中技术（如CSS，JavaS
      
    
    </summary>
    
      <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建独立博客教程</title>
    <link href="http://yoursite.com/2017/11/15/%E3%80%90Hexo%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%E3%80%91/"/>
    <id>http://yoursite.com/2017/11/15/【Hexo搭建独立博客教程】/</id>
    <published>2017-11-15T12:58:03.000Z</published>
    <updated>2017-12-03T15:01:47.485Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>在开始一切之前，你必须已经：</li></ul><ol><li><p>有一个github账号，没有的话去注册一个；</p></li><li><p>安装了node.js（官网下载安装），默认会安装npm。</p></li><li><p>安装git（官网下载安装）</p></li><li><p>安装hexo了，方法：打开git，输入cd运行npm install -g hexo（要翻墙）</p></li></ol><h3 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h3><ol><li><p>打开git，然后<strong>cd~/Desktop</strong></p></li><li><p>登录GitHub，在 GitHub 上新建一个空 repo，repo 名称是「你的用户名.github.io」。（请将你的用户名替换成真正的用户名</p></li><li><p>建立好空repo后，回到git命令行界面</p></li><li><p>运行<strong>npm install -g hexo-cli</strong>，安装Hexo</p></li><li><p>继续运行<strong>hexo init myBlog</strong></p></li><li><p>继续运行<strong>cd myBlog</strong></p></li><li><p>继续运行<strong>npm i</strong></p></li><li><p>运行<strong>hexo new开博大吉</strong>，你会看到一个md文件的路径</p></li><li><p>运行<strong>start xxxxxxxxxxxxxxxxxxx.md</strong>，编辑这个md文件，内容自己想（Ubuntu系统用xdg-open xxxxxxxxxxxxxxxxxxx.md命令）</p></li><li><p>继续运行<strong>start _config.yml</strong>，编辑网站配置</p><ul><li><p>把第 6 行的 title 改成你想要的名字 </p></li><li><p>把第 9 行的 author 改成你的大名 </p></li><li><p>把最后一行的 type 改成 type: git</p></li><li><p>在最后一行，在 type 下面，加上一行 <strong>repo: 仓库地址</strong> ，  仓库地址改为「你的用   户名.github.io」，仓库地址以 git@github.com: 开头格式如下</p><pre><code>&gt; repo:  git@github.com:你的用户名.github.io</code></pre></li><li><p>第 4 步的 repo:  后面有个空格，不要眼瞎</p></li></ul></li><li><p>继续运行<strong>npm install hexo-deployer-git –save</strong>，安装git部署插件</p></li><li><p>继续运行<strong>hexo deploy</strong></p></li><li><p>到这里博客已经搭建好了，打开Github，进入「你的用户名.github.io」对应的repo。</p></li><li><p>你现在应该看到了你的博客了。</p></li></ol><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><ol><li><p><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">主题</a>上面有主题合集</p></li><li><p>随便找一个主题，进入主题的GitHub首页，比如我找的是                             <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">链接</a></p></li><li><p>复制它的SSH地址或HTTPS地址，假设地址为 git@github.com:iissnan/hexo-theme-next.git</p></li><li><p>打开git命令行界面</p></li><li><p>运行<strong>cd themes</strong></p></li><li><p>运行<strong>git clone git@github.com:iissnan/hexo-theme-next.git</strong></p></li><li><p>运行<strong>cd ..</strong>　(这里意思是返回上一层)</p></li><li><p>将_config.yml的第75行改为<strong>theme: hexo-theme-next</strong>，保存</p></li><li><p>运行<strong>hexo generate</strong></p></li><li><p>运行<strong>hexo deploy</strong></p></li><li><p>等一分钟，然后刷新你的博客页面，你会看到一个新的外观。如果不喜欢这个主题，就回到第1步，重选一个主题。</p></li></ol><p>至此，博客已经搭建完成了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在开始一切之前，你必须已经：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;有一个github账号，没有的话去注
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
